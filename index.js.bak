const { default: makeWASocket, useMultiFileAuthState, DisconnectReason, fetchLatestBaileysVersion } = require('@whiskeysockets/baileys');
const P = require('pino');
const logger = P({ level: 'info' });
const fs = require('fs');
const os = require('os');
const path = require('path');
const axios = require('axios');
const colors = require('colors');
const chalk = require("chalk");
const gradient = require("gradient-string");
const { Boom } = require('@hapi/boom');
const exec = require('child_process').exec;
const number = process.env.WHATSAPP_NUMBER || 'default';
const qrcodePath = `./dados/sessoes/session-${number}`;
const donoInfo = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8'));
const https = require('https'); 
const infoDono = require('./dono/info');
const gruposDir = './dados/grupos';
const contadorPath = './dados/contador.json';
const pathFuncGp = './dados/funcgp.json';
const ffmpeg = require('fluent-ffmpeg');
const ytdl = require('ytdl-core');
const yts = require('yt-search');
const floodPrefixo = {};
const ignoradosPrefixo = {};
//infos
const infoGp = require('./dados/infogp.js');
const moment = require('moment-timezone');
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const FormData = require('form-data');
const { downloadMediaMessage } = require('@whiskeysockets/baileys');
const whatsapp = require('./whatsapp');
const { downloadContentFromMessage } = require('@whiskeysockets/baileys');
const { proto, generateWAMessageFromContent } = require('@whiskeysockets/baileys');
const agendamentos = {};
const caminhoFallback = './dados/fallback.json';
const spamBotMap = new Map();
const muteBotUsers = new Set();

global.db = require('./dados/database.json')
global.config = require('./dono/info.json')

// Adicione aqui:
global.sorteioAtivo = global.sorteioAtivo || {};
global.sorteioParticipantes = global.sorteioParticipantes || {};

const bloqueadosPath = './dados/bloqueados.json';

// Jogos
const memoria = require('./jogos/memoria');
const jogoVelha = require('./jogos/jogodavelha');
const campominado = require('./jogos/campominado');
const forca = require('./jogos/forca');
// Mutados
const mutedPath = './dados/muted.json';
let mutedUsers = fs.existsSync(mutedPath) ? JSON.parse(fs.readFileSync(mutedPath)) : {};
// Cache de metadata de grupos
const groupMetadataCache = {};
async function getGroupMetadataCached(jid, sock) {
  if (groupMetadataCache[jid]) return groupMetadataCache[jid];
  try {
    const metadata = await sock.groupMetadata(jid);
    groupMetadataCache[jid] = metadata;
    setTimeout(() => delete groupMetadataCache[jid], 30 * 1000);
    return metadata;
  } catch (err) {
    console.error('Erro ao obter metadata com cache:', err);
    throw err;
  }
}

async function executarAgendamento(sock, grupoId, tipo) {
  const abrir = tipo === 'gpa';
  const texto = abrir ? 'ğŸ”“ Grupo aberto automaticamente.' : 'ğŸ”’ Grupo fechado automaticamente.';

  await sock.groupSettingUpdate(grupoId, abrir ? 'not_announcement' : 'announcement');
  await sock.sendMessage(grupoId, { text: texto });
}

setInterval(async () => {
  const agora = new Date();
  const horaAtual = agora.toTimeString().slice(0, 5);
  for (const grupoId in agendamentos) {
    const agendamento = agendamentos[grupoId];
    if (!agendamento) {
      continue;
    }
    try {
      if (agendamento.gpa === horaAtual) {
        await executarAgendamento(sockGlobal, grupoId, 'gpa');
        delete agendamentos[grupoId].gpa;
        console.log(`ğŸ§¹ [LOG] Agendamento 'gpa' removido do grupo ${grupoId}`);
      }
      if (agendamento.gpf === horaAtual) {
        await executarAgendamento(sockGlobal, grupoId, 'gpf');
        delete agendamentos[grupoId].gpf;
      }
    } catch (err) {
      console.log(`âŒ [ERRO] Falha ao executar agendamento do grupo ${grupoId}:`, err.message || err);
    }
  }
}, 60 * 1000);

// InicializaÃ§Ã£o de diretÃ³rios
if (!fs.existsSync('./dados')) fs.mkdirSync('./dados', { recursive: true });
if (!fs.existsSync(gruposDir)) fs.mkdirSync(gruposDir, { recursive: true });
if (!fs.existsSync('./dados/sessoes')) fs.mkdirSync('./dados/sessoes', { recursive: true });

if (!fs.existsSync(contadorPath)) fs.writeFileSync(contadorPath, JSON.stringify({}));
let contador = JSON.parse(fs.readFileSync(contadorPath, 'utf-8'));
function salvarContador() {
  fs.writeFileSync(contadorPath, JSON.stringify(contador, null, 2));
}
function salvarMute() {
  fs.writeFileSync(mutedPath, JSON.stringify(mutedUsers, null, 2));
}

let sockGlobal;
const comandosPendentes = new Map();
function setSock(sock) {
  sockGlobal = sock;
  sockGlobal.ev.on('connection.update', async (update) => {
    if (update.connection === 'open') {
      for (const [grupoId, comando] of comandosPendentes.entries()) {
        try {
          await sockGlobal.sendMessage(grupoId, { text: comando });
          comandosPendentes.delete(grupoId);
          console.log(`âœ… Comando ${comando} enviado para ${grupoId}`);
        } catch (err) {
          console.log(`âŒ Falha ao enviar comando ${comando} para ${grupoId}: ${err.message}`);
        }
      }
    }
  });
}

function carregarConfigGrupo(grupoId) {
  const file = path.join(gruposDir, `${grupoId}.json`);
  if (!fs.existsSync(file)) {
    const configPadrao = {
      listanegra: [],
      antilink: false,
      antipromote: false,
      antiporno: false,
      antifake: false,
      blockgp: false,
      bemvindo: false,
      legendabv: "ğŸ’•OiÃª #membro#"
    };
    fs.writeFileSync(file, JSON.stringify(configPadrao, null, 2));
    return configPadrao;
  }
  try {
    const data = JSON.parse(fs.readFileSync(file, 'utf-8'));
    data.listanegra ??= [];
    data.antilink ??= false;
    data.antipromote ??= false;
    data.antiporno ??= false;
    data.antifake ??= false;
    data.blockgp ??= false;
    data.bemvindo ??= false;
    data.legendabv ??= "ğŸ’•OiÃª #membro#";
    return data;
  } catch {
    return {
      listanegra: [],
      antilink: false,
      antipromote: false,
      antiporno: false,
      antifake: false,
      blockgp: false,
      bemvindo: false,
      legendabv: "ğŸ’•OiÃª #membro#"
    };
  }
}
function salvarConfigGrupo(grupoId, config) {
  const file = path.join(gruposDir, `${grupoId}.json`);
  fs.writeFileSync(file, JSON.stringify(config, null, 2));
}
function salvarFallback(grupoId, tipo) {
  let data = {};
  if (fs.existsSync(caminhoFallback)) {
    data = JSON.parse(fs.readFileSync(caminhoFallback, 'utf-8'));
  }
  data[grupoId] = tipo;
  fs.writeFileSync(caminhoFallback, JSON.stringify(data, null, 2));
}
function removerFallback(grupoId) {
  if (fs.existsSync(caminhoFallback)) {
    const data = JSON.parse(fs.readFileSync(caminhoFallback, 'utf-8'));
    delete data[grupoId];
    fs.writeFileSync(caminhoFallback, JSON.stringify(data, null, 2));
  }
}

function carregarBloqueados() {
  if (!fs.existsSync(bloqueadosPath)) return [];
  return JSON.parse(fs.readFileSync(bloqueadosPath, 'utf-8'));
}

function salvarBloqueados(lista) {
  fs.writeFileSync(bloqueadosPath, JSON.stringify(lista, null, 2));
}

const antifloodDelay = 4888;
const userCooldown = new Map();
function podeExecutar(userId) {
  const agora = Date.now();
  if (!userCooldown.has(userId)) {
    userCooldown.set(userId, agora);
    return true;
  }
  const ultima = userCooldown.get(userId);
  if (agora - ultima > antifloodDelay) {
    userCooldown.set(userId, agora);
    return true;
  }
  return false;
}

async function upsert(m, sock) {
  const msg = m.messages && m.messages[0];
  if (!msg || msg.key.remoteJid === 'status@broadcast') return;
  const btnId = msg.message?.buttonsResponseMessage?.selectedButtonId;
  const from = msg.key.remoteJid;
  const isGroup = from.endsWith('@g.us');
  const sender = msg.key.participant || msg.key.remoteJid;
  const pushName = msg.pushName || '';
  if (!msg.message) return;
  const messageType = Object.keys(msg.message)[0];
  const tipoMidia = messageType;
  const isMedia = ['imageMessage', 'videoMessage', 'audioMessage', 'documentMessage'].includes(messageType);
  let text = '';
  if (messageType === 'conversation') text = msg.message.conversation || '';
  else if (messageType === 'extendedTextMessage') text = msg.message.extendedTextMessage.text || '';
  else if (messageType === 'imageMessage') text = '[Imagem]';
  else if (messageType === 'videoMessage') text = '[VÃ­deo]';
  else if (messageType === 'stickerMessage') text = '[Sticker]';
  else text = `[${messageType}]`;
  const body = text;
  let nomeGrupo = '';
  let grupoInfo = null;

  // AQUI: Chamada do contador
  if (isGroup && sender && from) contarMensagem(from, sender);
  if (isGroup) {
    try {
      grupoInfo = await getGroupMetadataCached(from, sock);
      nomeGrupo = grupoInfo.subject || '';
    } catch {
      nomeGrupo = '';
    }
  }

async function baixarMp3ComYtdlp(link, filename = 'audio.mp3') {
  return new Promise((resolve, reject) => {
    const output = path.join(__dirname, filename);
    const comando = `yt-dlp -x --audio-format mp3 -o "${output}" "${link}"`;
    exec(comando, (error, stdout, stderr) => {
      if (error) return reject(stderr || stdout || error);
      resolve(output);
    });
  });
}

const bloqueados = carregarBloqueados();
if (bloqueados.includes(sender)) return; 
if (isGroup && (msg.message?.imageMessage || msg.message?.viewOnceMessageV2)) {
  const configGrupo = carregarConfigGrupo(from);
  if (!configGrupo.antiporno) return;
  try {
    let imageMessage = null;
    if (msg.message?.viewOnceMessageV2?.message?.imageMessage) {
      const original = msg.message.viewOnceMessageV2.message.imageMessage;
      imageMessage = { ...original };
      delete imageMessage.viewOnce;
    }
    else if (msg.message?.imageMessage) {
      imageMessage = msg.message.imageMessage;
    }
    if (!imageMessage) return;
    const buffer = await downloadMediaMessage(
      msg,
      'buffer',
      {},
      { reuploadRequest: sock.updateMediaMessage }
    );
    if (!buffer) {
      console.error('âŒ Buffer vazio.');
      return;
    }
    const tmpDir = './tmp';
    if (!fs.existsSync(tmpDir)) fs.mkdirSync(tmpDir);
    const filePath = `${tmpDir}/${from}_${Date.now()}.jpg`;
    fs.writeFileSync(filePath, buffer);
    const form = new FormData();
    form.append('image', buffer.toString('base64'));  
const agent = new https.Agent({ rejectUnauthorized: false });
const upload = await axios.post(
  'https://api.imgbb.com/1/upload?key=c47bfc1637d9630c137daaf1e3a3cfb9',
  form,
  {
    headers: form.getHeaders(),
    httpsAgent: agent
  }
);
   
    const imageUrl = upload.data?.data?.url;
    if (!imageUrl) {
      console.error('âŒ Falha ao obter URL da imagem.');
      return;
    }
    const { data } = await axios.get('https://api.sightengine.com/1.0/check.json', {
      params: {
        models: 'nudity-2.1,weapon,gore-2.0,qr-content',
        api_user: '1678506124',
        api_secret: 'n5d3WWcSdCt9bwFwXrBXNwy5cQMTTPQD',
        url: imageUrl
      }
    });
    fs.unlink(filePath, err => {
      if (err) console.error(`Erro ao apagar imagem temporÃ¡ria: ${err.message}`);
    });
    const nudez = data.nudity?.sexual_activity > 0.7 || data.nudity?.sexual_display > 0.7;
    const arma = data.weapon?.prob > 0.8;
    const gore = data.gore?.prob > 0.8;
    if (nudez || arma || gore) {
      const isSenderAdmin = grupoInfo?.participants?.some(p => p.id === sender && p.admin);
      const tipoDetectado = nudez
        ? 'ğŸ” Nudez explÃ­cita detectada'
        : arma
        ? 'ğŸ”« Arma de fogo detectada'
        : 'ğŸ§  ConteÃºdo gore detectado';
      await sock.sendMessage(from, {
        text: `${isSenderAdmin ? 'âš ï¸' : 'ğŸš«'} @${sender.split('@')[0]}, ${tipoDetectado}${isSenderAdmin ? ', mas vocÃª Ã© admin.' : ''}`,
        mentions: [sender]
      }, { quoted: msg });
      if (!isSenderAdmin) {
        await sock.groupParticipantsUpdate(from, [sender], 'remove');
      }
    }
  } catch (err) {
    console.error('Erro ao processar imagem:', err);
  }
}

async function executarAgendamento(grupoId, comandoFallback) {
  try {
    if (!sockGlobal) throw new Error('Sock nÃ£o inicializado');   
    if (comandoFallback === 'gpa') {
      await sockGlobal.groupSettingUpdate(grupoId, 'not_announcement');
    } else if (comandoFallback === 'gpf') {
      await sockGlobal.groupSettingUpdate(grupoId, 'announcement');
    } else {
      throw new Error('Comando invÃ¡lido');
    }
    comandosPendentes.delete(grupoId);
    console.log(`âœ… Executado: ${comandoFallback} no grupo ${grupoId}`);
  } catch (err) {
    if (err.message.includes('Connection Closed')) {
      comandosPendentes.set(grupoId, comandoFallback);
      console.log(`âš ï¸ Sock fechado. Comando ${comandoFallback} pendente para ${grupoId}`);
    } else {
      console.log(`âŒ Falha ao executar ${comandoFallback} em ${grupoId}: ${err.message}`);
    }
  }
}
// Antilink
if (isGroup) {
  const texto = msg.message?.conversation
    || msg.message?.extendedTextMessage?.text
    || msg.message?.imageMessage?.caption
    || msg.message?.videoMessage?.caption
    || '';
  if (!texto) return;
  const configPath = `./dados/grupos/${from}.json`;
  if (fs.existsSync(configPath)) {
    const configGrupo = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    if (configGrupo.antilink && grupoInfo) {
      const remetente = msg.key.participant || sender;
      const isSenderAdmin = grupoInfo.participants.some(p => p.id === remetente && (p.admin === 'admin' || p.admin === 'superadmin'));
      const regexLink = /(https?:\/\/[^\s]+|www\.[^\s]+|\b(t\.me|wa\.me|chat\.whatsapp\.com|bit\.ly|linktr\.ee|discord\.gg)\/\S*)/i;
      const mencaoTodos = texto.includes('@all') || texto.includes('@todos') || texto.includes('@everyone');
      if ((regexLink.test(texto) || mencaoTodos) && !isSenderAdmin && !msg.key.fromMe) {
        try {
          await sock.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: msg.key.id, participant: remetente }});
          await sock.groupParticipantsUpdate(from, [remetente], 'remove');
          await sock.sendMessage(from, {
            text: `ğŸš¨ *${pushName || remetente.split('@')[0]}*, vocÃª violou as regras do grupo e foi removido por enviar link ou marcar todos.`
          }, { quoted: msg });
        } catch (err) {
          console.error('Erro ao remover usuÃ¡rio:', err);
        }
      }
    }
  }
}
  // Mutados
  if (isGroup && mutedUsers[from] && mutedUsers[from].includes(sender)) {
    try {
      await sock.sendMessage(from, {
        delete: {
          remoteJid: from,
          fromMe: false,
          id: msg.key.id,
          participant: sender
        }
      });
    } catch (e) {
      console.log('Erro ao deletar mensagem de mutado:', e);
    }
  }
// AntiTrava
if (isGroup && text) {
  const travasPerigosas = [
    '\u2063', '\u200B', '\u200E', '\u200F',
    '\u202A', '\u202B', '\u202C', '\u202D', '\u202E'
  ];
  const configGrupo = carregarConfigGrupo(from);
  const grupoAtivado = configGrupo.antitrava === true;
  const contemTrava = travasPerigosas.some(char => text.includes(char));
  const muitoGrande = text.length > 10000;
  if (grupoAtivado && (contemTrava || muitoGrande)) {
    try {
      const botNumber = (await sock.state.creds).me.id;
      const isBotAdmin = grupoInfo?.participants?.some(p => p.id === botNumber && p.admin);
      const isSenderAdmin = grupoInfo?.participants?.some(p => p.id === sender && p.admin);
      if (isSenderAdmin) {
        console.log(`ğŸ›¡ï¸ Mensagem de trava ignorada (ADM): ${sender} no grupo ${from}`);
        return;
      }
      await sock.sendMessage(from, {
        delete: {
          remoteJid: from,
          fromMe: false,
          id: msg.key.id,
          participant: sender
        }
      });
      await sock.sendMessage(from, {
        text: `ğŸš« *Mensagem de trava detectada!*\nUsuÃ¡rio: @${sender.split('@')[0]}`
      }, {
        quoted: msg,
        mentions: [sender]
      });
      if (isBotAdmin) {
        await sock.groupParticipantsUpdate(from, [sender], 'remove');
      }
    } catch (e) {
      console.error('âŒ Erro no antitrava:', e);
    }
    return;
  }
}
  // Log mensagem
  if (text) {
    const nomeGrupoOuPrivado = isGroup ? nomeGrupo : "Chat Privado";
    const nomeUsuario = pushName || sender.split('@')[0];
    const msgFormatada = text.length > 80 ? text.substring(0, 77) + '...' : text;
    const divisor = chalk.gray('â•­' + 'â”€'.repeat(34));
    const divisorInferior = chalk.gray('â•°' + 'â”€'.repeat(34));
    console.log('\n' + divisor);
    console.log(chalk.cyanBright.bold(`ğŸ“ ${nomeGrupoOuPrivado.toUpperCase()}`));
    console.log(chalk.yellow('ğŸ‘¤ ') + chalk.bold(nomeUsuario));
    console.log(chalk.greenBright('ğŸ’¬ ') + chalk.white(msgFormatada));
    console.log(divisorInferior);
  }
  // Contador
function contarMensagem(from, sender) {
  if (!contador[from]) contador[from] = {};
  if (!contador[from][sender]) contador[from][sender] = 0;
  contador[from][sender]++;
  salvarContador();
}
  const configGrupo = isGroup ? carregarConfigGrupo(from) : null;
  if (isGroup && configGrupo && Array.isArray(configGrupo.listanegra) && configGrupo.listanegra.includes(sender)) return;
  const msgLower = text.toLowerCase().trim();
  const command = msgLower.split(' ')[0];
  let isGroupAdmin = false;
  if (isGroup) {
    try {
      const groupMetadata = await getGroupMetadataCached(from, sock);
      const participant = groupMetadata.participants.find(p => p.id === sender);
      if (participant && (participant.admin === 'admin' || participant.admin === 'superadmin')) {
        isGroupAdmin = true;
      }
    } catch (e) {
      console.error("Erro ao verificar admin:", e);
    }
    if (configGrupo.blockgp && !isGroupAdmin) return;
  }
  const comandosGrupo = ['rankgado', 'menu', 'menuadm', 'ping', 'legendabv', 'stts', 'ativa', 'ban', 'totag', 'citar', 'marcar', 'antilink', 'perfil', 'rank', 'rankcorno', 'rankfeio', 'rankpau', 'rankputa', 'ranklindo', 'rankgay', 'rankclt', 'rankppk', 'limparcontador', 'play', 'videopraaudio', 'limpar', 'bloock', 'listblock', 'unbloock', 'antitrava', 'banghost', 'nuke', 'linkgp', 'playvd', 'blockgp', 'antifake', 'fs', 'ppk', 'pau', 'lavarlouca', 'toimg', 'vasco', 'beijar', 'matar', 'dono', 'criador', 'listanegra', 'verlista', 'tirardalista'];
  if (isGroup) {
  const partes = msgLower.trim().split(/\s+/);
  const comandoDetectado = partes[0];
  if (comandosGrupo.includes(comandoDetectado) && partes.length <= 2) {
    if (!podeExecutar(sender)) {
      await sock.sendMessage(from, {
        text: `ğŸ¤¡ NÃ£o  floda ze ruela, tinha q ser ${pushName}`
      }, { quoted: msg });
      return;
    }
  }
}
await whatsapp(sock, msg, from, msgLower);
 // INICIO DOS COMANDOS SEM PREFIXO
if (isGroup && msgLower === 'menu') {
  const { performance } = require('perf_hooks');
  const info = require('./dono/info.json');
  const getBuffer = async (url) => {
    try {
      const res = await axios.get(url, { responseType: 'arraybuffer' });
      return res.data;
    } catch (e) {
      console.error('Erro ao baixar thumbnail do menu:', e);
      return null;
    }
  };
  try {
    const sender = msg.key.participant || msg.participant || msg.key.remoteJid || from;
    const userTag = `@${sender.split('@')[0]}`;
    const isDono = sender.includes(info.numerodono);

    // Verifica se Ã© admin
    const groupMetadata = await sock.groupMetadata(from);
    const isAdmin = groupMetadata.participants?.some(p => p.id === sender && (p.admin === 'admin' || p.admin === 'superadmin'));
    const admStatus = isAdmin ? 'âœ…' : 'âŒ';
    const start = performance.now();
    await sock.sendMessage(from, {
      react: {
        text: 'ğŸ™‡ğŸ»â€â™€ï¸',
        key: msg.key
      }
    });
    const thumbnail = await getBuffer('https://i.postimg.cc/Gtr3K8bY/IMG-20250712-WA0027.jpg');
    const end = performance.now();
    const ping = Math.floor(end - start);
    const hora = new Date().toLocaleTimeString('pt-BR', { timeZone: 'America/Sao_Paulo' });
    const uptime = process.uptime();
    const uptimeHoras = Math.floor(uptime / 3600);
    const uptimeMin = Math.floor((uptime % 3600) / 60);
    const uptimeSeg = Math.floor(uptime % 60);
    const menuText =    
`â•­â”€ââââğŸ©¸âââââ”€â•®
â”‚âœ­ OiÃª ${userTag}
â”‚âœ­ á´›á´‡á´á´˜á´ á´É´: ${uptimeHoras}h ${uptimeMin}m ${uptimeSeg}s
â”‚âœ­ Êœá´Ê€á´€: ${hora}
â”‚âœ­ á´…á´É´á´: ${isDono ? 'â˜‘ï¸' : 'âŒ'}
â”‚âœ­ á´€á´…á´: ${admStatus}
â”‚âœ­ Ê™á´á´›: ${info.nomebot}
â•°â”€ââââğŸ©¸âââââ”€â•¯

â•­â”€âââââââââ”€â•®
â”ƒ ğŸ’ğ‚ğğŒğ€ğğƒğğ’ğŸ’ 
â•°â”€âââââââââ”€â•¯
â”ƒä¹¡Í¡ÍœÛœÛœğŸ‘‘Û£ _â–º menuadm_
  ğŸ’¬ğŒğ„ğŒğğ‘ğğ’
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º perfil_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º matar_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º beijar_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º dono_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º criador_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º toimg_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º bot_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º ping_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º sanizinha_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º fs_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º grupoofc_  
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸŒ _â–º sorteio_

â•­â”€âââââââââ”€â•®
â”ƒ   ğŸ­ğ™ğğ„ğˆğ‘ğ€ğŸ˜‚      
â•°â”€âââââââââ”€â•¯
â”ƒâœ°Í¡ÍœÛœÛœÛ£ğŸ  _â–º pau_
â”ƒâœ°Í¡ÍœÛœÛœÛ£ğŸ  _â–º ppk_
â”ƒâœ°Í¡ÍœÛœÛœÛ£ğŸ  _â–º lavarlouca_
â”ƒâœ°Í¡ÍœÛœÛœÛ£ğŸ  _â–º tapa_
â”ƒâœ°Í¡ÍœÛœÛœÛ£ğŸ  _â–º tapao_

â•­â”€âââââââââ”€â•®
â”ƒ  ğŸ¥‡ğ‘ğ€ğğŠğ’ğŸ†     
â•°â”€âââââââââ”€â•¯
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rank_  
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankgay_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankgado_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankcorno_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankfeio_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º ranklindo_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankputa_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankclt_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankpau_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ–ï¸ _â–º rankppk_

â•­â”€âââââââââ”€â•®
â”ƒ   ğŸ®ğ‰ğğ†ğğ’âš½
â•°â”€âââââââââ”€â•¯
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸ² _â–º dado_
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸ‘µğŸ» _â–º jogodavelha_
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸ’£ _â–º campominado_
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸ§© _â–º memoria_
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸ§¸ _â–º forca_

â•­â”€âââââââââ”€â•®
â”ƒğŸ”ğƒğğ–ğğ‹ğğ€ğƒğ’ğŸ”
â•°â”€âââââââââ”€â•¯
â”ƒä¹¡â™ªÍ¡ÍœÛœÛœÛ£ğŸ¶ _â–º play_
â”ƒä¹¡â™ªÍ¡ÍœÛœÛœÛ£ğŸ¶ _â–º playvd_
â”ƒä¹¡â™ªÍ¡ÍœÛœÛœÛ£ğŸ¶ _â–º videopraaudio_

â•­â”€âââââââââ”€â•®
â”ƒğŸ’­ğˆğğ…ğğ’/ğˆğƒğ„ğˆğ€ğ’ğŸ’¡
â•°â”€âââââââââ”€â•¯
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸª _â–º infogp_
â”ƒğ„¢Í¡ÍœÛœÛœÛ£ğŸª _â–º ideia_

â•°â”€â”€â”€â”€â”€â€¢ğ‘ºğ’‚ğ’ğ’Šğ’›ğ’Šğ’ğ’‰ğ’‚ğ‘©ğ’ğ’•â€¢â”€â”€â”€â”€â”€â•¯`;
    await sock.sendMessage(from, {
      text: menuText,
      mentions: [sender],
      contextInfo: {
        mentionedJid: [sender],
        externalAdReply: {
          title: 'ğŸª ğ— ğ—˜ğ—¡ğ—¨ ğ—œğ—¡ğ—œğ—–ğ—œğ—”ğ—Ÿ âœ¨',
          body: `âš¡ ğ˜—ğ˜ªğ˜¯ğ˜¨: ${ping}ms`,
          mediaType: 1,
          previewType: 0,
          renderLargerThumbnail: true,
          thumbnail,
          mediaUrl: 'https://linkfly.to/nexosfc',
          sourceUrl: 'https://nexosofc'
        }
      }
    }, { quoted: msg });

  } catch (err) {
    console.error('Erro ao enviar menu:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao carregar menu.'
    }, { quoted: msg });
  }
}

if (isGroup && msgLower === 'menuadm') {
  const { performance } = require('perf_hooks');
  const getBuffer = async (url) => (await axios.get(url, { responseType: 'arraybuffer' })).data;

  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }

  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}

  const ping = `${Math.floor(performance.now())}ms`;
  const thumbnail = await getBuffer('https://i.postimg.cc/Gtr3K8bY/IMG-20250712-WA0027.jpg');

  const senderId = sender.split('@')[0];
  const welcomeText = `âœ¨ğ‘©ğ’†ğ’ ğ’—ğ’Šğ’ğ’…ğ’ ğ’‚ğ’ ğ’ğ’†ğ’ğ’–ğ’‚ğ’…ğ’ğŸ’• @${senderId}\n`;

  const menuAdmText = 
`â•­â”â”â€à³‹âš˜ğŸ™‡â€â™€ï¸âš˜à³‹â€â”â”â•®
â”ƒ  ğŸ©¸ğ‚ğğŒğ€ğğƒğğ’ğŸ©¸ 
â•°â”â”â€à³‹âš˜ğŸ™‡â€â™€ï¸âš˜à³‹â€â”â”â•¯
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º gpa_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º gpf_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º ban/b_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º vasco_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º linkgp_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º mute_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º listanegra_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º tirardalista_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º verlista_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º desmute_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º antilink_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º antitrava_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º antiporno_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º antifake_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º bemvindo_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º legendabv_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º limpar_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º resetcontador_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º blockgp_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º marcar_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º totag_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ›¡ï¸ _â–º ativa <recursos>_

â•­â”â”â€à³‹âš˜ğŸ’âš˜à³‹â€â”â”â•®
â”ƒğŸ‘‘ğ‚ğğŒğ€ğğƒğğ’ ğƒğğğ
â•°â”â”â€à³‹âš˜ğŸ’âš˜à³‹â€â”â”â•¯
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º reiniciar_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º nuke_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º entrargp_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º sairgp_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º tmss_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º novodono_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º banghost_  
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º antipromote_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º bloock_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º unbloock_
â”ƒä¹¡Í¡ÍœÛœÛœÛ£ğŸ’ _â–º listblock_

â•°â”€â”€â”€â”€â”€â€¢ğ’”ğ’‚ğ’ğ’Šğ’›ğ’Šğ’ğ’‰ğ’‚ ğ’ƒğ’ğ’•â€¢â”€â”€â”€â”€â”€â•¯`;
  await sock.sendMessage(from, {
    text: welcomeText + menuAdmText,
    contextInfo: {
      mentionedJid: [sender],
      externalAdReply: {
        title: 'ğŸ‘‘ğ— ğ—˜ğ—¡ğ—¨ ğ—”ğ——ğ— ğŸ‘‘',
        body: `âš¡Ping: ${ping}`,
        mediaType: 1,
        previewType: 0,
        renderLargerThumbnail: true,
        thumbnail,
        mediaUrl: 'https://linkfly.to/nexosfc',
        sourceUrl: 'https://ğ˜¯ğ˜¦ğ˜¹ğ˜°ğ˜´ğ˜°ğ˜§ğ˜¤'
      }
    }
  }, { quoted: msg });
}

/*else if (
  msg.message?.conversation?.toLowerCase() === '.oi' ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() === '.oi'
) {
  try {
    const thumbnailUrl = 'https://i.postimg.cc/TPcszKxf/IMG-20250712-WA0026.jpg';
    const thumbBuffer = (await axios.get(thumbnailUrl, { responseType: 'arraybuffer' })).data;
    await sock.sendMessage(from, {
      text: `Oi, tudo bem? ğŸ’–`,
      contextInfo: {
        externalAdReply: {
          title: 'Sanizinha Bot',
          body: 'Seu bot favorito ğŸ’•',
          mediaType: 1,
          thumbnail: thumbBuffer,
          renderLargerThumbnail: false,
          showAdAttribution: false,
          sourceUrl: 'https://wa.me/554799999999'
        }
      }
    }, { quoted: msg });
  } catch (err) {
    console.error('Erro no comando .oi:', err);
    await sock.sendMessage(from, { text: 'âŒ Erro ao carregar a thumbnail.' }, { quoted: msg });
  }
}*/

else if (isGroup && msg.message?.conversation?.toLowerCase().includes('prefixo')) {
  const senderId = msg.key.participant || msg.key.remoteJid;

  if (ignoradosPrefixo[senderId] && Date.now() < ignoradosPrefixo[senderId]) {
    return;
  }

  if (!floodPrefixo[senderId]) floodPrefixo[senderId] = [];
  floodPrefixo[senderId].push(Date.now());

  floodPrefixo[senderId] = floodPrefixo[senderId].filter(ts => Date.now() - ts < 5000);

  if (floodPrefixo[senderId].length >= 3) {
    ignoradosPrefixo[senderId] = Date.now() + 10 * 60 * 1000;

    await sock.sendMessage(from, {
      text: 'Ei! Para de flodar meus circuitos, seu jeca ğŸ˜¡',
    }, { quoted: msg });

    await sock.sendMessage(from, {
      sticker: fs.readFileSync('./dados/figurinhas/flodprefixo.webp')
    }, { quoted: msg });

    return;
  }

  await sock.sendMessage(from, {
    text: 'ğŸ˜‚ *Prefixo? Eu sou modernağŸ‘ï¸ğŸ‘„ğŸ‘ï¸, nÃ£o uso isso mais nÃ£o!*\nSÃ³ digita o comando direto, exemplo: `play Anitta`, `menu`, `ping`',
  }, { quoted: msg });

  await sock.sendMessage(from, {
    sticker: fs.readFileSync('./dados/figurinhas/prefixo.webp')
  }, { quoted: msg });

  try {
    await sock.sendMessage(from, {
      react: { text: 'ğŸ¤­', key: msg.key }
    });
  } catch (e) {
    console.error('Erro ao reagir:', e);
  }
}

else if (msgLower === 'grupoofc') {
  const getBuffer = async (url) => (await axios.get(url, { responseType: 'arraybuffer' })).data;

  try {
    const thumbnail = await getBuffer('https://files.catbox.moe/vqlhbo.jpg');

    await sock.sendMessage(from, {
      text: 'ğŸ’ğ‚ğ¡ğšğ­ ğ§ğğ±ğ¨ğ¬ ğŸğœ:\n\nhttps://linkfly.to/nexosfc',
      contextInfo: {
        externalAdReply: {
          title: 'ğ†ğ‘ğ”ğğ ğ’ğ€ğğˆğ™ğˆğğ‡ğ€ğğğ“',
          body: 'Clique para acessar o grupo agora!',
          thumbnail,
          mediaType: 1,
          previewType: 'PHOTO',
          mediaUrl: 'https://linkfly.to/nexosfc',
          sourceUrl: 'https://linkfly.to/nexosfc'
        }
      }
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro ao carregar thumbnail:', e.message);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao carregar imagem. Aqui estÃ¡ o link do grupo:\nhttps://linkfly.to/nexosfc'
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower.startsWith('listanegra')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const groupId = from;
  const configPath = `./dados/grupos/${groupId}.json`;
  if (!fs.existsSync(configPath)) {
    fs.writeFileSync(configPath, JSON.stringify({ listanegra: [] }, null, 2));
  }
  const configGrupo = JSON.parse(fs.readFileSync(configPath));
  let alvo = null;
  if (msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length) {
    alvo = msg.message.extendedTextMessage.contextInfo.mentionedJid[0];
  }
  else if (msg.message?.extendedTextMessage?.contextInfo?.participant) {
    alvo = msg.message.extendedTextMessage.contextInfo.participant;
  }
  else if (text.split(' ')[1]) {
    let numero = text.split(' ')[1].replace(/\D/g, '');
    if (numero.length >= 10) {
      alvo = numero + '@s.whatsapp.net';
    }
  }
  if (!alvo) {
    await sock.sendMessage(from, { text: 'âŒ Marque, ou digite o nÃºmero do usuÃ¡rio' }, { quoted: msg });
    return;
  }
  if (!configGrupo.listanegra.includes(alvo)) {
    configGrupo.listanegra.push(alvo);
    fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
    await sock.sendMessage(from, { text: `*UsuÃ¡rio adicionado Ã  lista negrağŸ’€:*\n\nâ€¢ ${alvo.replace(/@s\.whatsapp\.net/, '')}` }, { quoted: msg });
  } else {
    await sock.sendMessage(from, { text: `âš ï¸ Esse usuÃ¡rio jÃ¡ estÃ¡ na lista negra.` }, { quoted: msg });
  }
}

// VER LISTA NEGRA
else if (isGroup && /^([!.])?verlista\b/i.test(msgLower)) {
  const grupoPath = `./dados/grupos/${from}.json`;
  if (!fs.existsSync(grupoPath)) return await sock.sendMessage(from, { text: 'âš ï¸ Nenhuma lista negra encontrada.', quoted: msg });
  const config = JSON.parse(fs.readFileSync(grupoPath));
  const lista = config.listanegra || [];
  if (lista.length === 0) return await sock.sendMessage(from, { text: 'âœ… Nenhum nÃºmero na lista negra.', quoted: msg });
  const numeros = lista.map(n => `@${n.split('@')[0]}`).join('\n');
  await sock.sendMessage(from, { text: `ğŸ›‘ *Lista Negra:*\n\n${numeros}`, mentions: lista }, { quoted: msg });
}

// REMOVER DA LISTA
else if (isGroup && msgLower.startsWith('tirardalista')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const grupoPath = `./dados/grupos/${from}.json`;
  if (!fs.existsSync(grupoPath)) {
    fs.writeFileSync(grupoPath, JSON.stringify({ listanegra: [] }, null, 2));
  }
  const configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  if (!configGrupo.listanegra) configGrupo.listanegra = [];
  let alvo;
  if (msg.message?.extendedTextMessage?.contextInfo?.participant) {
    alvo = msg.message.extendedTextMessage.contextInfo.participant.replace(/[^0-9]/g, '');
  } else if (text.split(' ')[1]) {
    alvo = text.split(' ')[1].replace(/[^0-9]/g, '');
  }
  if (!alvo) {
    await sock.sendMessage(from, { text: 'âŒ Marque um usuÃ¡rio, mencione ou informe o nÃºmero para remover da lista negra.' }, { quoted: msg });
    return;
  }
  const jid = `${alvo}@s.whatsapp.net`;
  if (!configGrupo.listanegra.includes(jid)) {
    await sock.sendMessage(from, { text: `âŒ O nÃºmero ${alvo} nÃ£o estÃ¡ na lista negra.` }, { quoted: msg });
    return;
  }
  configGrupo.listanegra = configGrupo.listanegra.filter(n => n !== jid);
  fs.writeFileSync(grupoPath, JSON.stringify(configGrupo, null, 2));
  await sock.sendMessage(from, { text: `âœ… O nÃºmero ${alvo} foi removido da lista negra.` }, { quoted: msg });
}

else if (isGroup && /^([!.])?(ping)$/i.test(msgLower)) {
  const { performance } = require('perf_hooks');
  const { totalmem, freemem, platform, arch, cpus } = os;
  try {
    await sock.sendMessage(from, {
      react: {
        text: 'âš¡',
        key: msg.key
      }
    });
    const startTime = performance.now();
    await sock.sendMessage(from, {
      text: '*â³ğ˜Šğ˜¢ğ˜­ğ˜¤ğ˜¶ğ˜­ğ˜¢ğ˜¯ğ˜¥ğ˜° ğ˜·ğ˜¦ğ˜­ğ˜°ğ˜¤ğ˜ªğ˜¥ğ˜¢ğ˜¥ğ˜¦...*',
      contextInfo: {
        externalAdReply: {
          title: 'ğ˜Šğ˜¢ğ˜­ğ˜¤ğ˜¶ğ˜­ğ˜¢ğ˜¯ğ˜¥ğ˜° ğ˜±ğ˜ªğ˜¯ğ˜¨...',
          body: 'â±ï¸ğ˜ˆğ˜¨ğ˜¶ğ˜¢ğ˜³ğ˜¥ğ˜¦',
          thumbnailUrl: 'https://files.catbox.moe/qnhouw.gif',
          sourceUrl: 'https://ğ˜¯ğ˜¦ğ˜¹ğ˜°ğ˜´ğ˜°ğ˜§ğ˜¤',
          mediaType: 1,
          renderLargerThumbnail: false,
          showAdAttribution: false
        }
      }
    });
    const endTime = performance.now();
    const velocidade = Math.floor(endTime - startTime);
    const used = process.memoryUsage().rss / 1024 / 1024;
    const totalRam = totalmem() / 1024 / 1024;
    const cpuInfo = cpus()?.[0]?.model || 'CpuQuÃ¢ntico';
    const uptimeSec = Math.floor(process.uptime());
    const uptimeHoras = Math.floor(uptimeSec / 3600);
    const uptimeMin = Math.floor((uptimeSec % 3600) / 60);
    const uptimeRest = uptimeSec % 60;
    const plataforma = platform();
    const arquitetura = arch();
    const thumbnailFinal = velocidade > 360
      ? 'https://files.catbox.moe/702329.jpg'
      : 'https://files.catbox.moe/3ei78v.jpg';
    const textoFinal =
      `*ğ˜ğ˜¦ğ˜­ğ˜°ğ˜¤ğ˜ªğ˜¥ğ˜¢ğ˜¥ğ˜¦ ğ˜®ğ˜¦ğ˜¥ğ˜ªğ˜¥ğ˜¢ ğ˜¦ğ˜® ${velocidade}ms!*\n` +
      `ğŸ§  *ğ˜Šğ˜—ğ˜œ:* ${cpuInfo}\n` +
      `ğŸ“Š *ğ˜™ğ˜ˆğ˜” ğ˜Œğ˜” ğ˜œğ˜šğ˜–:* ${used.toFixed(2)}MB\n` +
      `ğŸ“Š *ğ˜™ğ˜ˆğ˜” ğ˜›ğ˜–ğ˜›ğ˜ˆğ˜“:* ${totalRam.toFixed(2)}MB\n` +
      `ğŸ“± *ğ˜šğ˜ğ˜šğ˜›ğ˜Œğ˜”ğ˜ˆ:* ${plataforma} ${arquitetura}\n` +
      `ğŸ• *ğ˜›ğ˜”ğ˜— ğ˜–ğ˜•ğ˜“ğ˜ğ˜•ğ˜Œ:* ${uptimeHoras}h ${uptimeMin}m ${uptimeRest}s`;
    await sock.sendMessage(from, {
      text: textoFinal,
      contextInfo: {
        externalAdReply: {
          title: 'Ping concluÃ­do!',
          body: `âš¡ ${velocidade}ms`,
          thumbnailUrl: thumbnailFinal,
          sourceUrl: 'https://ğ˜¯ğ˜¦ğ˜¹ğ˜°ğ˜´ğ˜°ğ˜§ğ˜¤',
          mediaType: 1,
          renderLargerThumbnail: false,
          showAdAttribution: false
        }
      }
    });
  } catch (err) {
    await sock.sendMessage(from, { text: 'âŒ Erro ao medir ping.' }, { quoted: msg });
    console.error('Erro ao medir ping:', err);
  }
}

 else if (isGroup && /^([!.])?dono$/i.test(msgLower)) {
    // âš¡ ReaÃ§Ã£o antes de iniciar o ping
    await sock.sendMessage(from, {
      react: {
        text: 'ğŸ‘‘',
        key: msg.key
      }
    });  
  const getBuffer = async (url) => (await axios.get(url, { responseType: 'arraybuffer' })).data;
  const info = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8'));
  const nomeDono = info.nick || 'Dono';
  const numeroDono = info.numerodono || '559999999999';
  const nomeBot = info.nomebot || 'Bot';
  const thumbnail = await getBuffer('https://files.catbox.moe/aeakfl.jpg'); // miniatura
  const vcard = `
BEGIN:VCARD
VERSION:3.0
FN:${nomeDono}
ORG:${nomeBot};
TEL;type=CELL;type=VOICE;waid=${numeroDono}:+${numeroDono}
END:VCARD`.trim();
  await sock.sendMessage(from, {
    contacts: {
      displayName: nomeDono,
      contacts: [{ vcard }]
    },
    contextInfo: {
      externalAdReply: {
        title: `ğŸ‘‘ ğ——ğ—¼ğ—»ğ—¼ ğ—±ğ—¼ ${nomeBot}`,
        body: `ğ—–ğ—¼ğ—»ğ˜ğ—®ğ˜ğ—¼ ğ—±ğ—² ${nomeDono}`,
        mediaType: 1,
        renderLargerThumbnail: true,
        previewType: 0,
        thumbnail,
        sourceUrl: 'https://nexosofc'
      }
    }
  }, { quoted: msg });
} 
  // Comando stts
else if (isGroup && msgLower === 'stts') {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(from, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/g3o2dt.gif';
  }
  const thumbnailBuffer = await axios.get(ppUrl, { responseType: 'arraybuffer' }).then(res => res.data);
  const statusText = `
â•­â•â€¢ à³‹à¹‘ğŸ›¡ï¸à¹‘à³‹ â€¢â•â•®
â”ƒğ’ğ“ğ€ğ“ğ”ğ’ ğƒğ ğ†ğ‘ğ”ğğ
â•°â•â€¢ à³‹à¹‘ğŸ›¡ï¸à¹‘à³‹ â€¢â•â•¯
â”ƒâ˜ï¸ antilink:        ${configGrupo.antilink ? 'âœ…' : 'âŒ'}
â”ƒâ˜ï¸ antipromote:   ${configGrupo.antipromote ? 'âœ…' : 'âŒ'}
â”ƒâ˜ï¸ antiporno:     ${configGrupo.antiporno ? 'âœ…' : 'âŒ'}
â”ƒâ˜ï¸ antifake:       ${configGrupo.antifake ? 'âœ…' : 'âŒ'}
â”ƒâ˜ï¸ antitrava:      ${configGrupo.antitrava ? 'âœ…' : 'âŒ'} 
â”ƒâ˜ï¸ bemvindo:     ${configGrupo.bemvindo ? 'âœ…' : 'âŒ'}
â”ƒâ˜ï¸ blockgp:       ${configGrupo.blockgp ? 'âœ…' : 'âŒ'}
â•°â•â€¢ à³‹âœ§à¹‘âœ¨à¹‘âœ§à³‹ â€¢â•â•¯
â”ƒ  ğŸ©· SanizinhaBot sempre com vocÃª!
`;
  await sock.sendMessage(from, {
    text: statusText,
    contextInfo: {
      externalAdReply: {
        title: 'âœ¨ STATUS DO GRUPO',
        body: 'ğŸŒº ğ˜´ğ˜¢ğ˜¯ğ˜ª ğ˜¥ğ˜°ğ˜®ğ˜ªğ˜¯ğ˜¢â‚á¢â‘…â€¢á´—â€¢â‘…á¢â‚â™¡',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: true,
        sourceUrl: 'https://nexosofc'
      }
    }
  }, { quoted: msg });
}
 
else if (msg.message?.conversation?.startsWith('tmss ') || msg.message?.extendedTextMessage?.text?.startsWith('tmss ')) {
  const donoData = JSON.parse(fs.readFileSync('./dono/info.json'));
  const numeroDono = donoData.numerodono.replace(/\D/g, '');
  const senderNumber = sender.replace(/\D/g, '');

  if (senderNumber !== numeroDono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono do bot pode usar este comando.' }, { quoted: msg });
    return;
  }
  let texto = '';
  if (msg.message.conversation && msg.message.conversation.startsWith('tmss ')) {
    texto = msg.message.conversation.slice(6).trim();
  } else if (msg.message.extendedTextMessage && msg.message.extendedTextMessage.text.startsWith('tmss ')) {
    texto = msg.message.extendedTextMessage.text.slice(6).trim();
  }
  if (!texto) {
    await sock.sendMessage(from, { text: 'âŒ Escreva a mensagem da transmissÃ£o.\nExemplo: .tmss BOT ONLINE NOVAMENTE' }, { quoted: msg });
    return;
  }
  const allChats = await sock.groupFetchAllParticipating();
  const groups = Object.values(allChats).filter(g => g.id.endsWith('@g.us'));
  const thumbnailUrl = 'https://files.catbox.moe/xrthcw.jpg';
  const thumbnailBuffer = await axios.get(thumbnailUrl, { responseType: 'arraybuffer' }).then(res => res.data);
  for (const group of groups) {
    const metadata = await sock.groupMetadata(group.id);
    const mentions = metadata.participants.map(p => p.id);
    await sock.sendMessage(group.id, {
      text: `*ğŸ“¢ TRANSMISSÃƒO:*\n${texto}`,
      mentions,
      contextInfo: {
        externalAdReply: {
          title: 'ğŸš¨ TRANSMISSÃƒO GLOBAL',
          body: 'SanizinhaBot - by Sani',
          mediaType: 1,
          thumbnail: thumbnailBuffer,
          sourceUrl: 'https://whatsapp.com'
        }
      }
    });

    await new Promise(r => setTimeout(r, 1200));
  }
  await sock.sendMessage(from, { text: 'âœ… TransmissÃ£o enviada para todos os grupos com sucesso!' }, { quoted: msg });
}
    
else if (isGroup && /^([!.])?linkgp\b/i.test(msgLower)) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
    const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
    if (!botIsAdmin) {
      await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para obter o link do grupo.' }, { quoted: msg });
      return;
    }
    const inviteCode = await sock.groupInviteCode(from);
    const nomeGrupo = groupMetadata.subject || "Grupo";
    const linkGrupo = `https://chat.whatsapp.com/${inviteCode}`;
    let fotoGrupo;
    try {
      fotoGrupo = await sock.profilePictureUrl(from, 'image');
    } catch {
      fotoGrupo = 'https://i.imgur.com/qZ3BKG3.png';
    }
    await sock.sendMessage(from, {
      text: `*ğŸ”—ğŸ’•Link do grupo* *${nomeGrupo}*:\n${linkGrupo}`,
      contextInfo: {
        externalAdReply: {
          title: `ğŸ”— ${nomeGrupo}`,
          body: 'ğŸŒŸ Clique para entrar no grupo!',
          mediaType: 2,
          thumbnailUrl: fotoGrupo,
          mediaUrl: linkGrupo,
          sourceUrl: linkGrupo,
          showAdAttribution: false
        }
      }
    }, { quoted: msg });
  } catch (error) {
    console.error('Erro ao gerar link do grupo:', error);
    await sock.sendMessage(from, { text: 'âŒ Erro ao obter o link do grupo.' }, { quoted: msg });
  }
}

else if (isGroup && /^([!.])?rank$/i.test(msgLower)) {
  const contadorPath = './dados/contador.json';
  if (!fs.existsSync(contadorPath)) {
    await sock.sendMessage(from, { text: 'âŒ Nenhuma atividade registrada ainda.' }, { quoted: msg });
    return;
  }
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {} 
  const contador = JSON.parse(fs.readFileSync(contadorPath, 'utf-8'));
  const grupoContador = contador[from] || {};
  const membrosValidos = Object.entries(grupoContador)
    .filter(([id]) => !id.endsWith('@g.us'))
    .sort((a, b) => b[1] - a[1])
    .slice(0, 20);
  if (membrosValidos.length === 0) {
    await sock.sendMessage(from, { text: 'âŒ Nenhum membro ativo encontrado.' }, { quoted: msg });
    return;
  }
  const numerosBonitos = ['Â¹', 'Â²', 'Â³', 'â´', 'âµ', 'â¶', 'â·', 'â¸', 'â¹', 'Â¹â°', 'Â¹Â¹', 'Â¹Â²', 'Â¹Â³', 'Â¹â´', 'Â¹âµ', 'Â¹â¶', 'Â¹â·', 'Â¹â¸', 'Â¹â¹', 'Â²â°'];
  let rankMsg = 'ğŸ† *RANK DOS MAIS ATIVOS DO GRUPO*\n\n';
  const mentions = [];
  for (let i = 0; i < membrosValidos.length; i++) {
    const [id, count] = membrosValidos[i];
    const numero = id.split('@')[0];
    rankMsg += `${numerosBonitos[i]} @${numero}  _${count} msg_\n`;
    mentions.push(id);
  }
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(from, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/g3o2dt.gif';
  }
  const thumbnailBuffer = await axios.get(ppUrl, { responseType: 'arraybuffer' }).then(res => res.data);
  await sock.sendMessage(from, {
    text: rankMsg,
    mentions,
    contextInfo: {
      mentionedJid: mentions,
      externalAdReply: {
        title: 'ğŸ† ğ‘ğ€ğğŠ ğ€ğ“ğˆğ•ğğ’',
        body: 'ğğ¬ ğ¦ğšğ¢ğ¬ ğ©ğšğ«ğ­ğ¢ğœğ¢ğ©ğšğ­ğ¢ğ¯ğ¨ğ¬ ğğ¨ ğ ğ«ğ®ğ©ğ¨!',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: true,
        sourceUrl: 'https://ğ˜¯ğ˜¦ğ˜¹ğ˜°ğ˜´ğ˜°ğ˜§ğ˜¤'
      }
    }
  }, { quoted: msg });
}
    
  else if (isGroup && /^\.?(limparcontador|resetcontador)\b/i.test(msgLower)) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const contadorPath = path.resolve(__dirname, './dados/contador.json');
  try {
    fs.writeFileSync(contadorPath, '{}', { encoding: 'utf8', flag: 'w' });
    contador = {}; // Resetar em memÃ³ria tambÃ©m!
    await sock.sendMessage(from, { text: 'âœ… Contador zerado com sucesso!' }, { quoted: msg });
  } catch (e) {
    console.error('Erro ao limpar contador:', e);
    await sock.sendMessage(from, { text: 'âŒ Erro ao limpar contador.' }, { quoted: msg });
  }
}
  
  if (isGroup && msgLower === 'limpar') {
  if (!isGroupAdmin && !msg.key.fromMe) {
    await sock.sendMessage(from, { text: 'âŒ Apenas admins podem usar este comando!' }, { quoted: msg });
    return;
  }   
  const invisivel = '\n \n \n '.repeat(5000);
  for (let i = 0; i < 7; i++) {
    await sock.sendMessage(from, { text: invisivel });
    await sleep(500);
  }
  await sock.sendMessage(from, { text: 'ğŸ§¹ Chat limpo com sucesso!' }, { quoted: msg });
}
  
  else if (isGroup && msgLower.startsWith('ativa')) {
    if (!isGroupAdmin) {
      await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
      return;
    }
    const args = text.trim().split(/\s+/).slice(1);
    if (args.length === 0) {
      await sock.sendMessage(from, { text: 'Uso: ativa <recursos separados por espaÃ§o>' }, { quoted: msg });
      return;
    }
    const validRecursos = ['antilink', 'blockgp', 'antiporno', 'antifake', 'bemvindo'];
    let ativados = [];
    let invalidos = [];
    for (const recurso of args) {
      if (validRecursos.includes(recurso.toLowerCase())) {
        configGrupo[recurso.toLowerCase()] = true;
        ativados.push(recurso.toLowerCase());
      } else {
        invalidos.push(recurso);
      }
    }
    salvarConfigGrupo(from, configGrupo);
    let resposta = '';
    if (ativados.length > 0) {
      resposta += `âœ… Ativados: ${ativados.join(', ')}\n`;
    }
    if (invalidos.length > 0) {
      resposta += `âŒ InvÃ¡lidos: ${invalidos.join(', ')}`;
    }
    await sock.sendMessage(from, { text: resposta.trim() }, { quoted: msg });
  }
  
    
if (isGroup && /^([!.])?(ban|b)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botParticipant = groupMetadata.participants.find(p => p.id === botNumber);
  const botIsAdmin = botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin');
  if (!botIsAdmin) {
    await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para remover membros.' }, { quoted: msg });
    return;
  }

  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar esse comando.' }, { quoted: msg });
    return;
  }

  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}

  let mentioned = [];
  try {
    mentioned = msg.message?.[Object.keys(msg.message)[0]]?.contextInfo?.mentionedJid || [];
  } catch {}

  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const quotedMessage = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage || null;

  const alvos = new Set();
  for (const jid of mentioned) alvos.add(jid);
  if (quotedParticipant) alvos.add(quotedParticipant);

  if (alvos.size === 0) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque alguÃ©m com @ ou responda Ã  mensagem da pessoa que deseja banir.',
      quoted: msg
    });
    return;
  }

  const isLink = (text) => {
    return /https?:\/\/|www\.|\.com|\.net|\.org|\.gov|globo|cutt\.ly|bit\.ly|tinyurl|wa\.me|t\.me|@/i.test(text || '');
  };
  const isTagAll = (text) => {
    return /@(\d{5,}|todos|everyone|all)/gi.test(text || '');
  };

  for (const jid of alvos) {
    if (jid === botNumber) {
      await sock.sendMessage(from, { text: 'âš ï¸ Eu nÃ£o posso me banir.' }, { quoted: msg });
      continue;
    }

    const senderIsAdmin = groupMetadata.participants.find(p => p.id === sender)?.admin;
    const autorPodeBanir = senderIsAdmin === 'admin' || senderIsAdmin === 'superadmin';

    if (!autorPodeBanir) {
      if (quotedMessage) {
        const tipoMsg = Object.keys(quotedMessage)[0];
        const conteudoAlvo = quotedMessage[tipoMsg]?.text || quotedMessage[tipoMsg]?.caption || '';
        if (!isLink(conteudoAlvo) && !isTagAll(conteudoAlvo)) {
          await sock.sendMessage(from, {
            text: 'âŒ SÃ³ posso banir se a mensagem respondida for suspeita (link ou marcaÃ§Ã£o a todos).',
            quoted: msg
          });
          continue;
        }
      } else {
        await sock.sendMessage(from, {
          text: 'âŒ SÃ³ posso banir se vocÃª responder Ã  mensagem suspeita (link ou marcaÃ§Ã£o a todos).',
          quoted: msg
        });
        continue;
      }
    }

    try {
      await sock.groupParticipantsUpdate(from, [jid], 'remove');
      await sock.sendMessage(from, {
        text: `@${jid.split('@')[0]} _foi banido(a)_ âš°ï¸`,
        mentions: [jid]
      }, { quoted: msg });
    } catch (e) {
      console.error(`Erro ao banir ${jid}:`, e);
      await sock.sendMessage(from, {
        text: `âŒ Falha ao banir @${jid.split('@')[0]}`,
        mentions: [jid]
      }, { quoted: msg });
    }
  }
}

if (isGroup && /^([!.])?(vasco|vascodagama)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const isCmdByAdmin = isGroupAdmin;
  let mentioned = [];
  try {
    mentioned = msg.message?.[Object.keys(msg.message)[0]]?.contextInfo?.mentionedJid || [];
  } catch {}
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
  const quotedMessage = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
  const alvos = new Set();
  for (const jid of mentioned) alvos.add(jid);
  if (quotedParticipant) alvos.add(quotedParticipant);
  const isLink = (text) => {
    return /https?:\/\/|www\.|\.com|\.net|\.org|\.gov|globo|cutt\.ly|bit\.ly|tinyurl|wa\.me|t\.me|@/i.test(text || '');
  };
  const isTagAll = (text) => {
    return /@(\d{5,}|todos|everyone|all)/gi.test(text || '');
  };
  if (alvos.size > 0 && botIsAdmin) {
    for (const jid of alvos) {
      if (jid === botNumber) {
        await sock.sendMessage(from, { text: 'âš ï¸ Eu nÃ£o posso me banir.' }, { quoted: msg });
        continue;
      }
      if (!isCmdByAdmin) {
        let conteudoAlvo = '';
        const tipo = Object.keys(quotedMessage || {})[0];
        if (tipo && quotedMessage[tipo]) {
          conteudoAlvo = quotedMessage[tipo]?.text || quotedMessage[tipo]?.caption || '';
        }
        if (!isLink(conteudoAlvo) && !isTagAll(conteudoAlvo)) {
          await sock.sendMessage(from, {
            text: 'âŒ SÃ³ posso banir se a mensagem for suspeita (link ou marcaÃ§Ã£o a todos). Marcar uma pessoa nÃ£o Ã© suficiente.',
            quoted: msg
          });
          continue;
        }
      }
      try {
        await sock.groupParticipantsUpdate(from, [jid], 'remove');
        await sock.sendMessage(from, {
          text: ` @${jid.split('@')[0]} _ğ…ğ¨ğ¢ ğğ ğ…âš°ï¸_ .`,
          mentions: [jid]
        }, { quoted: msg });
        const random = Math.floor(Math.random() * 3) + 1; // 1 a 3
        const figuPath = `./dados/figurinhas/vasco${random}.webp`;
        try {
          const figuBuffer = fs.readFileSync(figuPath);
          await sock.sendMessage(from, { sticker: figuBuffer }, { quoted: msg });
        } catch (e) {
          console.error('Erro ao enviar figurinha do Vasco:', e);
        }
        try {
          const audioBuffer = fs.readFileSync('./dados/figurinhas/vasco.mp3');
          await sock.sendMessage(from, {
            audio: audioBuffer,
            mimetype: 'audio/mp4',
            ptt: true
          }, { quoted: msg });
        } catch (e) {
          console.error('Erro ao enviar Ã¡udio do Vasco:', e);
        }
      } catch {
        await sock.sendMessage(from, {
          text: `âŒ Falha ao banir @${jid.split('@')[0]}`,
          mentions: [jid]
        }, { quoted: msg });
      }
    }
  } else if (alvos.size > 0 && !botIsAdmin) {
    await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para remover membros.' }, { quoted: msg });
  } else if (alvos.size === 0) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque alguÃ©m com @ ou responda Ã  mensagem da pessoa que deseja banir.',
    }, { quoted: msg });
  }
}

if (isGroup && /^([!.])?(promover|pp)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
  if (!botIsAdmin) {
    await sock.sendMessage(from, {
      text: 'âš ï¸ Eu preciso ser administrador para promover.'
    }, { quoted: msg });
    return;
  }
  const grupoPath = `./dados/grupos/${from}.json`;
  let configGrupo = { antipromote: false };
  if (fs.existsSync(grupoPath)) {
    configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  }
  const donoJson = JSON.parse(fs.readFileSync('./dono/info.json'));
  const dono = donoJson?.dono?.replace(/\D/g, '') + '@s.whatsapp.net';
  let mentioned = [];
  try {
    mentioned = msg.message?.[Object.keys(msg.message)[0]]?.contextInfo?.mentionedJid || [];
  } catch {}
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
  const alvos = new Set();
  mentioned.forEach(jid => alvos.add(jid));
  if (quotedParticipant) alvos.add(quotedParticipant);
  if (alvos.size === 0) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque alguÃ©m com @ ou responda Ã  msg do usuario.'
    }, { quoted: msg });
    return;
  }
  let thumbBuffer = null;
  try {
    const thumbRes = await axios.get(
      'https://i.postimg.cc/5yhQjP7L/20250702-131415.jpg',
      { responseType: 'arraybuffer' }
    );
    thumbBuffer = thumbRes.data;
  } catch (e) {
    console.log('Erro baixar thumbnail:', e);
  }
  for (const jid of alvos) {
    if (!jid.endsWith('@s.whatsapp.net')) continue;
    if (jid === botNumber) {
      await sock.sendMessage(from, {
        text: 'NÃ£o posso promover a mim mesmoğŸ˜‚.'
      }, { quoted: msg });
      continue;
    }
    const isSenderDono = sender === dono;
    const isSenderBot = sender === botNumber;
    if (configGrupo.antipromote && !isSenderDono && !isSenderBot) {
      try {
        await sock.groupParticipantsUpdate(from, [sender], 'demote');
        await sock.sendMessage(from, {
          text: `â›” AntiPromote ativado.\n@${sender.split('@')[0]} foi rebaixado por tentar promover alguÃ©m.`,
          mentions: [sender]
        }, { quoted: msg });
      } catch (e) {
        console.log('Erro ao tentar rebaixar o autor:', e);
      }
      continue;
    }
    try {
      await sock.groupParticipantsUpdate(from, [jid], 'promote');
      const userNumber = jid.split('@')[0];
      const texto = `âœ… @${userNumber} foi promovido a adm.`;
      await sock.sendMessage(from, {
        text: texto,
        mentions: [jid],
        contextInfo: {
          mentionedJid: [jid],
          externalAdReply: {
            title: 'ğğ¨ğ¯ğ¨ ğšğğ¦ ğ§ğš ğšğ«ğğšğŸ‘€!',
            body: 'âœ¨ğğğ¦ ğ¯ğ¢ğ§ğğ¨ ğš ğ«ğğšğ¥ğğ³ğšğŸ‘‘',
            thumbnail: thumbBuffer,
            mediaType: 1,
            showAdAttribution: false,
            sourceUrl: `https://wa.me/${userNumber}`
          }
        }
      }, { quoted: msg });

    } catch (e) {
      console.log('Erro ao promover:', e);
      await sock.sendMessage(from, {
        text: `âŒ NÃ£o consegui promover @${jid.split('@')[0]}.`,
        mentions: [jid]
      }, { quoted: msg });
    }
  }
}

if (msgLower === 'antiporno') {
  const numerodono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  if (sender.split('@')[0] !== numerodono) {
    await sock.sendMessage(from, { text: 'ğŸš« Apenas o dono do bot pode ativar ou desativar o AntiPornÃ´.' }, { quoted: msg });
    return;
  }

  const config = carregarConfigGrupo(from);
  config.antiporno = !config.antiporno;
  salvarConfigGrupo(from, config);

  await sock.sendMessage(from, {
    text: `ğŸ” AntiPornÃ´ ${config.antiporno ? 'ativado' : 'desativado'} com sucesso!`
  }, { quoted: msg });
}


else if (isGroup && /^\.?mute\b/i.test(msgLower)) {
  if (!isGroupAdmin) return sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });

  const quoted = msg.message?.extendedTextMessage?.contextInfo?.participant;
  const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const alvo = quoted || (mentioned.length > 0 ? mentioned[0] : null);

  if (!alvo) {
    await sock.sendMessage(from, { text: 'âŒ Marque ou responda a mensagem de quem vocÃª quer mutar.' }, { quoted: msg });
    return;
  }

  if (!mutedUsers[from]) mutedUsers[from] = [];
  if (!mutedUsers[from].includes(alvo)) mutedUsers[from].push(alvo);
  salvarMute();

  await sock.sendMessage(from, {
    text: `ğŸ”‡ O usuÃ¡rio @${alvo.split('@')[0]} foi mutado!`,
    mentions: [alvo]
  }, { quoted: msg });
}
else if (isGroup && /^\.?desmute\b/i.test(msgLower)) {
  if (!isGroupAdmin) return sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });

  const quoted = msg.message?.extendedTextMessage?.contextInfo?.participant;
  const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const alvo = quoted || (mentioned.length > 0 ? mentioned[0] : null);

  if (!alvo || !mutedUsers[from] || !mutedUsers[from].includes(alvo)) {
    await sock.sendMessage(from, { text: 'âš ï¸ Este usuÃ¡rio nÃ£o estÃ¡ mutado.' }, { quoted: msg });
    return;
  }

  mutedUsers[from] = mutedUsers[from].filter(id => id !== alvo);
  if (mutedUsers[from].length === 0) delete mutedUsers[from];
  salvarMute();

  await sock.sendMessage(from, {
    text: `ğŸ”Š O usuÃ¡rio @${alvo.split('@')[0]} foi desmutado!`,
    mentions: [alvo]
  }, { quoted: msg });
}

if (msgLower.startsWith('novodono')) {
  if (!donoInfo || !donoInfo.numerodono) {
    await sock.sendMessage(from, { text: 'âŒ O nÃºmero do dono atual nÃ£o estÃ¡ configurado corretamente.' }, { quoted: msg });
    return;
  }
  const donoAtual = donoInfo.numerodono.includes('@s.whatsapp.net') ? donoInfo.numerodono : donoInfo.numerodono + '@s.whatsapp.net';
  if (sender !== donoAtual) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono atual pode alterar o nÃºmero do dono.' }, { quoted: msg });
    return;
  }
  const novoNumero = msgLower.split(' ')[1]?.replace(/\D/g, '');
  if (!novoNumero || novoNumero.length < 10) {
    await sock.sendMessage(from, { text: 'âš ï¸ Use: novodono 5511999999999' }, { quoted: msg });
    return;
  }
  donoInfo.numerodono = novoNumero;
  fs.writeFileSync('./dono/info.json', JSON.stringify(donoInfo, null, 2));
  await sock.sendMessage(from, {
    text: `âœ… NÃºmero do dono atualizado com sucesso para:\nğŸ“ ${novoNumero}`
  }, { quoted: msg });
}


else if (isGroup && msgLower.startsWith('banghost')) {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (senderSemDDD !== dono) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas o dono do bot pode usar este comando.'
    }, { quoted: msg });
    return;
  }
  const partes = msgLower.trim().split(' ');
  const limite = partes[1] ? parseInt(partes[1]) : null;
  if (partes[1] && isNaN(limite)) {
    await sock.sendMessage(from, {
      text: 'âŒ Limite invÃ¡lido. Envie um nÃºmero, ex: banghost 10'
    }, { quoted: msg });
    return;
  }
  const filePath = './dados/contador.json';
  if (!fs.existsSync(filePath)) {
    await sock.sendMessage(from, {
      text: 'âŒ Nenhum contador encontrado.'
    }, { quoted: msg });
    return;
  }
  const dados = JSON.parse(fs.readFileSync(filePath));
  const contadorGrupo = dados[from] || {};
  const metadata = await sock.groupMetadata(from);
  const admins = metadata.participants.filter(p => p.admin !== null).map(p => p.id);
  const jidDono = dono + '@s.whatsapp.net';
  const membrosRemover = metadata.participants
    .filter(p => {
      const msgs = contadorGrupo[p.id] || 0;
      if (p.id === jidDono) return false;
      if (admins.includes(p.id)) return false;
      if (limite === null) return !(p.id in contadorGrupo);
      return msgs <= limite;
    })
    .map(p => p.id);
  if (membrosRemover.length === 0) {
    await sock.sendMessage(from, {
      text: 'âœ… Nenhum membro encontrado para remover com esse critÃ©rio.'
    }, { quoted: msg });
    return;
  }
  const removerEmLotes = async (lista, tamanho = 3) => {
    for (let i = 0; i < lista.length; i += tamanho) {
      const lote = lista.slice(i, i + tamanho);
      try {
        await sock.groupParticipantsUpdate(from, lote, 'remove');
      } catch (e) {
        console.error(`Erro ao remover membros: ${e}`);
      }
      await new Promise(resolve => setTimeout(resolve, 3000));
    }
  };
  await sock.sendMessage(from, {
    text: `ğŸ”ª Removendo ${membrosRemover.length} membro(s) com â‰¤ ${limite ?? '0'} mensagens...`
  }, { quoted: msg });
  await removerEmLotes(membrosRemover);
  await sock.sendMessage(from, {
    text: 'âœ… RemoÃ§Ã£o concluÃ­da com sucesso.'
  });
}

else if (isGroup && msgLower === 'antipromote') {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (senderSemDDD !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono do bot pode usar este comando.' }, { quoted: msg });
    return;
  }
  const grupoPath = `./dados/grupos/${from}.json`;
  let configGrupo = {
    antipromote: false
  };
  if (fs.existsSync(grupoPath)) {
    configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  }
  configGrupo.antipromote = !configGrupo.antipromote;
  fs.writeFileSync(grupoPath, JSON.stringify(configGrupo, null, 2));
  const status = configGrupo.antipromote ? 'ativado' : 'desativado';
  await sock.sendMessage(from, { text: `ğŸ›¡ï¸ AntiPromote ${status} com sucesso.` }, { quoted: msg });
}

if (isGroup && /^([!.])?(rebaixar|rebaix)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
  if (!botIsAdmin) {
    await sock.sendMessage(from, {
      text: 'âš ï¸ Eu preciso ser administrador para rebaixar membros.'
    }, { quoted: msg });
    return;
  }
  const grupoPath = `./dados/grupos/${from}.json`;
  let configGrupo = { antipromote: false };
  if (fs.existsSync(grupoPath)) {
    configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  }
  const donoJson = JSON.parse(fs.readFileSync('./dono/info.json'));
  const dono = donoJson?.dono?.replace(/\D/g, '') + '@s.whatsapp.net';
  let mentioned = [];
  try {
    mentioned = msg.message?.[Object.keys(msg.message)[0]]?.contextInfo?.mentionedJid || [];
  } catch {}
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
  const alvos = new Set();
  mentioned.forEach(jid => alvos.add(jid));
  if (quotedParticipant) alvos.add(quotedParticipant);
  if (alvos.size === 0) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque alguÃ©m com @ ou responda Ã  mensagem da pessoa que deseja rebaixar.'
    }, { quoted: msg });
    return;
  }
  // âœ… Carrega imagem normalmente como buffer
  let thumbBuffer = null;
  try {
    const thumbRes = await axios.get(
      'https://i.postimg.cc/VLPTp288/20250702-141427.jpg',
      { responseType: 'arraybuffer' }
    );
    thumbBuffer = thumbRes.data;
  } catch (e) {
    console.log('Erro ao baixar thumbnail:', e);
  }
  for (const jid of alvos) {
    if (!jid.endsWith('@s.whatsapp.net')) continue;

    if (jid === botNumber) {
      await sock.sendMessage(from, {
        text: 'âš ï¸ Eu jÃ¡ sou o bot. NÃ£o posso rebaixar a mim mesmo.'
      }, { quoted: msg });
      continue;
    }
    const isSenderDono = sender === dono;
    const isSenderBot = sender === botNumber;
    if (configGrupo.antipromote && !isSenderDono && !isSenderBot) {
      try {
        await sock.groupParticipantsUpdate(from, [sender], 'demote');
        await sock.sendMessage(from, {
          text: `â›” AntiPromote ativado.\n@${sender.split('@')[0]} foi rebaixado por tentar rebaixar alguÃ©m.`,
          mentions: [sender]
        }, { quoted: msg });
      } catch (e) {
        console.log('Erro ao tentar rebaixar o autor:', e);
      }
      continue;
    }
    try {
      await sock.groupParticipantsUpdate(from, [jid], 'demote');
      const userNumber = jid.split('@')[0];
      const texto = `ğŸ¥² @${userNumber} *rebaixado*.`;
      await sock.sendMessage(from, {
        text: texto,
        mentions: [jid],
        contextInfo: {
          mentionedJid: [jid],
          externalAdReply: {
            title: 'Expulso da realezaâ—',
            body: 'ğŸ«µğŸ˜‚',
            thumbnail: thumbBuffer,
            mediaType: 1,
            showAdAttribution: false,
            sourceUrl: `https://wa.me/${userNumber}`
          }
        }
      }, { quoted: msg });
    } catch (e) {
      console.log('Erro ao rebaixar:', e);
      await sock.sendMessage(from, {
        text: `âŒ NÃ£o consegui rebaixar @${jid.split('@')[0]}.`,
        mentions: [jid]
      }, { quoted: msg });
    }
  }
}

if (isGroup && /^([!.])?(sermembro)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
  if (!botIsAdmin) {
    await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para rebaixar membros.' }, { quoted: msg });
    return;
  }

  await sock.groupParticipantsUpdate(from, [sender], 'demote');
  await sock.sendMessage(from, { text: 'ğŸ”½ VocÃª foi rebaixado por vontade prÃ³pria.' }, { quoted: msg });
}

if (isGroup && /^([!.])?(seradm)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
  if (!botIsAdmin) {
    await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para promover alguÃ©m.' }, { quoted: msg });
    return;
  }

  const donoJson = JSON.parse(fs.readFileSync('./dono/info.json'));
  const dono = donoJson?.dono?.replace(/\D/g, '') + '@s.whatsapp.net';

  if (sender !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Somente o dono do bot pode usar este comando.' }, { quoted: msg });
    return;
  }

  await sock.groupParticipantsUpdate(from, [sender], 'promote');
  await sock.sendMessage(from, { text: 'âœ… Dono promovido com sucesso!' }, { quoted: msg });
}

// figurinha
if (msgLower === 'fs') {
  let quoted = null;
  if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage) {
    quoted = msg.message.extendedTextMessage.contextInfo;
  }
  if (!quoted) {
    await sock.sendMessage(from, { text: 'â—Marque uma *imagem* ou *vÃ­deo de atÃ© 9 segundos* para transformar em figurinha.' }, { quoted: msg });
    return;
  }
  const isImage = quoted.quotedMessage?.imageMessage;
  const isVideo = quoted.quotedMessage?.videoMessage;
  if (!isImage && !isVideo) {
    await sock.sendMessage(from, { text: 'â—Apenas *imagem* ou *vÃ­deo curto* sÃ£o suportados para figurinha.' }, { quoted: msg });
    return;
  }
  const mediaType = isImage ? 'imageMessage' : 'videoMessage';
  const buffer = await downloadMediaMessage(
    { message: { [mediaType]: quoted.quotedMessage[mediaType] } },
    'buffer'
  );
  if (!buffer) {
    await sock.sendMessage(from, { text: 'âŒ Falha ao baixar a mÃ­dia.' }, { quoted: msg });
    return;
  }
  if (isVideo) {
    const duration = quoted.quotedMessage.videoMessage.seconds;
    if (duration > 9) {
      await sock.sendMessage(from, { text: 'âŒ O vÃ­deo deve ter no mÃ¡ximo 9 segundos.' }, { quoted: msg });
      return;
    }
  }
  const tempInput = `./temp/${Date.now()}.${isImage ? 'jpg' : 'mp4'}`;
  const tempOutput = `./temp/${Date.now()}.webp`;
  fs.mkdirSync('./temp', { recursive: true });
  fs.writeFileSync(tempInput, buffer);
  exec(`ffmpeg -i ${tempInput} -vf "scale=512:512:force_original_aspect_ratio=decrease,fps=15,pad=512:512:(ow-iw)/2:(oh-ih)/2" -vcodec libwebp -lossless 0 -q:v 50 -loop 0 -an -vsync 0 -t 9 ${tempOutput}`, async (err) => {
    if (err) {
      console.error('Erro ao converter para webp:', err);
      await sock.sendMessage(from, { text: 'âŒ Falha ao criar figurinha.' }, { quoted: msg });
    } else {
      const stickerBuffer = fs.readFileSync(tempOutput);
      await sock.sendMessage(from, { sticker: stickerBuffer }, { quoted: msg });
      fs.unlinkSync(tempInput);
      fs.unlinkSync(tempOutput);
    }
  });
}

else if (isGroup && /^([!.])?(beijo|beijar|bj)\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);
  if (!target) {
    await sock.sendMessage(from, {
      text: 'ğŸ˜— Marque quem vocÃª quer beijar',
    }, { quoted: msg });
    return;
  }
  const texto = `ğŸ’‹ğŸŒ¹ @${sender.split('@')[0]} tascou um beijo cinematogrÃ¡fico em @${target.split('@')[0]}! A paixÃ£o estÃ¡ no ar!â¤ï¸â€ğŸ”¥ğŸ’•ğŸ‘ï¸ğŸ«¦ğŸ‘ï¸`;
  const videos = [
    'https://files.catbox.moe/wyrrby.mp4',
    'https://files.catbox.moe/b79cpy.mp4'
  ];
  const randomVideo = videos[Math.floor(Math.random() * videos.length)];
  try {
    await sock.sendMessage(from, {
      video: { url: randomVideo },
      caption: texto,
      gifPlayback: true,
      mentions: [sender, target],
    }, { quoted: msg });
    const audioBuffer = fs.readFileSync('./dados/figurinhas/beijo.mp3');
    await sock.sendMessage(from, {
      audio: audioBuffer,
      mimetype: 'audio/mp4',
      ptt: true
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando beijo:", e);
    await sock.sendMessage(from, { text: 'âŒ Ocorreu um erro ao tentar enviar o beijo.' }, { quoted: msg });
  }
}

else if (isGroup && /^tapa\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const groupMetadata = isGroup ? await sock.groupMetadata(from) : {};
  const participantes = groupMetadata?.participants || [];
  const target = quotedParticipant || (mentionedJid.length > 0 ? mentionedJid[0] : sender);
  const userTag = `@${target.split('@')[0]}`;

  // Reagir ğŸ‘
  await sock.sendMessage(from, {
    react: {
      text: "ğŸ‘",
      key: msg.key
    }
  });

  // Seleciona um vÃ­deo aleatÃ³rio
  const rand = Math.floor(Math.random() * 8) + 1;
  const videoPath = `./dados/figurinhas/tapa${rand}.mp4`;

  // Define legenda padrÃ£o
  let caption = `ğŸ‘‹ *${userTag}, vocÃª levou um tapa!*`;
  let mentions = [target];

  // Se for tapa4, altera a legenda para o erro de tapa
  if (rand === 4 && participantes.length > 2) {
    const outros = participantes
      .filter(p => p.id !== target && p.id !== sender)
      .map(p => p.id);
    const aleatorio = outros[Math.floor(Math.random() * outros.length)];
    const erroTag = `@${aleatorio.split('@')[0]}`;
    caption = `ğŸ˜… Vix... tentou dar um tapa em ${userTag}, mas acabou acertando ${erroTag} sem querer kkk`;
    mentions = [target, aleatorio];
  }

  // Envia o vÃ­deo com a legenda apropriada
  await sock.sendMessage(from, {
    video: fs.readFileSync(videoPath),
    caption,
    gifPlayback: true,
    mentions
  }, { quoted: msg });
}

else if (isGroup && /^([!.])?tapao\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);
  if (!target) {
    await sock.sendMessage(from, {
      text: 'ğŸ–ï¸ Marque alguÃ©m pra levar um tapÃ£o!',
    }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, {
    react: {
      text: "ğŸ‘",
      key: msg.key
    }
  });
  const frases = [
    'Tomou um tapÃ£o que atÃ© girou! ğŸ˜‚',
    'Isso aqui foi pra aprender a nÃ£o falar besteira! ğŸ«¢',
    'PlÃ¡Ã¡Ã¡! Ouvi daqui! ğŸ˜‚',
    'Agora acorda, que esse tapa foi de realidade! ğŸ’¢',
    'Quem mandou vacilar? TapÃ£o neles! ğŸ’¥',
    'Foi de mÃ£o aberta, sem dÃ³ nem piedade! ğŸ˜¤',
    'A bochecha tÃ¡ atÃ© vermelha agora! ğŸ˜³',
    'Avisa quando quiser outro! ğŸ‘‹',
    'Reage aÃ­ depois dessa! ğŸ”¥'
  ];
  const fraseAleatoria = frases[Math.floor(Math.random() * frases.length)];
  const texto = `ğŸ’¢ğŸ”¥ @${sender.split('@')[0]} *deu um tapÃ£o em* @${target.split('@')[0]}!\n${fraseAleatoria}`;
  try {
    const videoBuffer = fs.readFileSync('./dados/figurinhas/tapa.mp4');
    await sock.sendMessage(from, {
      video: videoBuffer,
      caption: texto,
      gifPlayback: true,
      mentions: [sender, target]
    }, { quoted: msg });
  } catch (err) {
    console.error('Erro no comando tapa:', err);
    await sock.sendMessage(from, { text: 'âŒ Ocorreu um erro ao tentar enviar o vÃ­deo.' }, { quoted: msg });
  }
}

else if (isGroup && /^([!.])?(lavarlouÃ§a|lavarlouca)\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);
  if (!target) {
    await sock.sendMessage(from, {
      text: 'ğŸ½ï¸ Marque alguÃ©m para lavar a louÃ§a!',
    }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, {
    react: {
      text: "ğŸ§½",
      key: msg.key
    }
  });
  const frases = [
    'NÃ£o adianta correr, a pia te espera! ğŸ˜‚',
    'Coragem, campeÃ£o... a louÃ§a nÃ£o se lava sozinha! ğŸ½ï¸',
    'Mais sujo que essa louÃ§a sÃ³ suas desculpas! ğŸ«§',
    'Lava aÃ­ rapidinho e volta pro grupo! ğŸ’¦',
    'A louÃ§a nÃ£o vai se lavar sozinha, amigÃ£o! ğŸ§¼',
    'MissÃ£o dada Ã© missÃ£o cumprida! ğŸ§½',
    'Vai lÃ¡ mostrar que sabe esfregar um prato! ğŸ›',
    'Seu nome foi sorteado pra lavar hoje! ğŸ¯',
    'O grupo inteiro agradece seu esforÃ§o na pia! ğŸ™Œ'
  ];
  const fraseAleatoria = frases[Math.floor(Math.random() * frases.length)];
  const texto = `ğŸ§¼ğŸ½ï¸ @${sender.split('@')[0]} mandou @${target.split('@')[0]} lavar a louÃ§a!\n${fraseAleatoria}`;
  try {
    const videoBuffer = fs.readFileSync('./dados/figurinhas/lavarlouca.mp4');
    await sock.sendMessage(from, {
      video: videoBuffer,
      caption: texto,
      gifPlayback: true,
      mentions: [sender, target]
    }, { quoted: msg });
  } catch (err) {
    console.error('Erro no comando lavarlouca:', err);
    await sock.sendMessage(from, { text: 'âŒ Ocorreu um erro ao tentar enviar o vÃ­deo.' }, { quoted: msg });
  }
}

else if (isGroup && /\b(pinga|pinguÃ§o|cachaceiro|cachaÃ§a|bÃªbado|bÃªbada|cachaceira|pinguÃ§a)\b/i.test(msgLower)) {
  try {
    if (sock.sendMessage && msg.key) {
      await sock.sendMessage(from, {
        react: {
          text: 'ğŸ»',
          key: msg.key
        }
      });
    }
    const audioBuffer = fs.readFileSync('./dados/figurinhas/pinga.mp3');
    await sock.sendMessage(from, {
      audio: audioBuffer,
      mimetype: 'audio/mp4',
      ptt: true
    }, { quoted: msg });
    const stickerBuffer = fs.readFileSync('./dados/figurinhas/pinga.webp');
    await sock.sendMessage(from, {
      sticker: stickerBuffer
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando pinga:", e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao executar o comando pinga.'
    }, { quoted: msg });
  }
}

else if (msgLower === 'sairgp') {
  if (!isGroup) return;
  if (sender !== infoDono.numerodono + '@s.whatsapp.net') {
    await sock.sendMessage(from, { text: 'âŒ Comando exclusivo do dono.' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { text: '_ğŸ‘‹ Saindo_' }, { quoted: msg });
  await sock.groupLeave(from);
}

else if (!isGroup && msgLower.startsWith('entrargp ')) {
  const linkGrupo = body.split(' ')[1]?.trim();
  if (!linkGrupo || !linkGrupo.includes('whatsapp.com')) {
    await sock.sendMessage(from, { text: 'âŒ Link invÃ¡lido.' }, { quoted: msg });
    return;
  }
  try {
    const inviteCode = linkGrupo.split('/')[3];
    await sock.groupAcceptInvite(inviteCode);
    await sock.sendMessage(from, { text: '*ğŸ’•Entrei no grupo mestreğŸ™‡ğŸ»â€â™€ï¸*' }, { quoted: msg });
  } catch (e) {
    console.error('Erro ao entrar no grupo:', e);
    await sock.sendMessage(from, { text: 'âŒ Erro ao tentar entrar no grupo.' }, { quoted: msg });
  }
}


else if (msgLower === 'sorteio' && isGroup) {
  if (global.sorteioAtivo?.[from]) {
    await sock.sendMessage(from, { text: 'âš ï¸ Um sorteio jÃ¡ estÃ¡ em andamento.' }, { quoted: msg });
    return;
  }
  global.sorteioAtivo = global.sorteioAtivo || {};
  global.sorteioParticipantes = global.sorteioParticipantes || {};
  global.sorteioAtivo[from] = true;
  global.sorteioParticipantes[from] = [];
  const participantes = global.sorteioParticipantes[from];
  const metadata = await sock.groupMetadata(from);
  const groupMembers = metadata.participants;
  const allJids = groupMembers.map(m => m.id);
  const textoInicial = `ğŸ‰ *SORTEIO INICIADO!*\n\nMande "eu" no chat pra participar!\nâ³ VocÃª tem *1 MINUTO* para entrar!`;
  const msgSorteio = await sock.sendMessage(from, {
    text: textoInicial,
    mentions: allJids
  }, { quoted: msg });
  const listener = async (update) => {
    if (!global.sorteioAtivo[from]) return;
    if (update.type !== 'notify') return;
    const messages = update.messages;
    if (!messages || messages.length === 0) return;
    const uMsg = messages[0];
    if (!uMsg.message || !uMsg.key || !uMsg.key.remoteJid) return;
    if (uMsg.key.remoteJid !== from) return;
    let uText = '';
    if (uMsg.message.conversation) uText = uMsg.message.conversation.toLowerCase();
    else if (uMsg.message.extendedTextMessage?.text) 
      uText = uMsg.message.extendedTextMessage.text.toLowerCase();
    else return;
    const uSender = uMsg.key.participant || uMsg.key.remoteJid;
    if (uText === 'eu' && !participantes.includes(uSender)) {
      participantes.push(uSender);
      await sock.sendMessage(from, {
        text: `âœ… @${uSender.split('@')[0]} entrou no sorteio!`,
        mentions: [uSender]
      });
    }
  };
  sock.ev.on('messages.upsert', listener);
  setTimeout(async () => {
    global.sorteioAtivo[from] = false;
    sock.ev.off('messages.upsert', listener);
    if (participantes.length === 0) {
      await sock.sendMessage(from, { text: 'âŒ NinguÃ©m participou do sorteio.' });
      return;
    }
    let msgContagem = await sock.sendMessage(from, {
      text: 'â³ InscriÃ§Ãµes encerradas! Sorteio comeÃ§a em 10 segundos...'
    });
    for (let i = 10; i >= 1; i--) {
      await new Promise(r => setTimeout(r, 1000));
      await sock.sendMessage(from, {
        text: ` _Sorteando em:_ *${i}*...`,
        edit: msgContagem.key
      });
    }
    const sorteado = participantes[Math.floor(Math.random() * participantes.length)];
    await sock.sendMessage(from, {
      text: `ğŸ¥³ PARABÃ‰NS @${sorteado.split('@')[0]}!\n\nğŸ VocÃª foi o *SORTEADO*!`,
      mentions: [sorteado]
    });
    global.sorteioParticipantes[from] = [];
  }, 60000);
}

else if (isGroup && /\b(calvo|calva)\b/i.test(msgLower)) {
  try {
    if (sock.sendMessage && msg.key) {
      await sock.sendMessage(from, {
        react: {
          text: 'ğŸ¤¡',
          key: msg.key
        }
      });
    }
    const audioBuffer = fs.readFileSync('./dados/figurinhas/calvo.mp3');
    await sock.sendMessage(from, {
      audio: audioBuffer,
      mimetype: 'audio/mp4',
      ptt: true
    }, { quoted: msg });
    const stickerBuffer = fs.readFileSync('./dados/figurinhas/calvo.webp');
    await sock.sendMessage(from, {
      sticker: stickerBuffer
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando calvo", e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao executar o comando calvo.'
    }, { quoted: msg });
  }
}

else if (isGroup && /^ppk\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant || (mentionedJid.length > 0 ? mentionedJid[0] : sender);
  const userTag = `@${target.split('@')[0]}`;
  if (typeof reagir === 'function') {
    setTimeout(() => reagir(from, "ğŸ‘€", msg), 300);
  }
  let msgMedindoPpk = await sock.sendMessage(from, {
    text: `*Medindo a profundidade da ppk de* ${userTag} ğŸ«¸ğŸ«·ğŸ¤”`,
    mentions: [target]
  }, { quoted: msg });
  await sleep(1000);
  await sock.sendMessage(from, {
    edit: msgMedindoPpk.key,
    text: `*Medindo a largura da ppk de* ${userTag} ğŸ«¸ğŸ«·ğŸ§`,
    mentions: [target]
  });
  await sleep(1000);
  await sock.sendMessage(from, {
    edit: msgMedindoPpk.key,
    text: `*calma ta quase lağŸ˜‚* ${userTag} ğŸ«¸ ğŸ«· ğŸ¤”`,
    mentions: [target]
  });
  const tamanhoPpk = Math.floor(Math.random() * 48) + 1;
  let legendaPpk = '';
  let imagemPpk = '';
  if (tamanhoPpk <= 10) {
    legendaPpk = `*Apertadinha demais...*\nâ‡’ ${userTag}\nProfundidade: âœ®${tamanhoPpk}cmâœ®\nCabe nem um cotonete ğŸ˜‚`;
    imagemPpk = "https://i.postimg.cc/N08T7bDh/20250704-204329.jpg";
  } else if (tamanhoPpk <= 30) {
    legendaPpk = `*Tamanho perfeito...*\nâ‡’ ${userTag}\nProfundidade: âœ®${tamanhoPpk}cmâœ®\nIdeal pra maldade ğŸ‘€`;
    imagemPpk = "https://i.postimg.cc/639ZHRb8/20250704-204435.jpg";
  } else if (tamanhoPpk < 45) {
    legendaPpk = `*Eitaaaa!!*\nâ‡’ ${userTag}\nProfundidade: âœ®${tamanhoPpk}cmâœ®\nAbismo detectado ğŸ˜‚ğŸ‘ï¸ğŸ‘„ğŸ‘ï¸`;
    imagemPpk = "https://i.postimg.cc/MZ3BDn7G/20250704-204454.jpg";
  } else {
    legendaPpk = `*QUE ISSO CAVERNA??*\nâ‡’ ${userTag}\nProfundidade absurda: âœ®${tamanhoPpk}cmâœ®\nO famoso POCOTÃ“ ğŸ´`;
    imagemPpk = "https://i.postimg.cc/MZg7wcvF/images-7.jpg";
  }
  await sock.sendMessage(from, {
    image: { url: imagemPpk },
    caption: legendaPpk,
    mentions: [target]
  }, { quoted: msg });
}

else if (isGroup && /^pau\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant || (mentionedJid.length > 0 ? mentionedJid[0] : sender);
  const userTag = `@${target.split('@')[0]}`;
  if (typeof reagir === 'function') {
    setTimeout(() => reagir(from, "ğŸ˜³", msg), 300);
  }
  let msgMedindoPau = await sock.sendMessage(from, {
    text: `*Medindo o tamanho do pau de* ${userTag} ğŸ«¸ğŸ«·ğŸ¤”`,
    mentions: [target]
  }, { quoted: msg });
  await sleep(1500);
  await sock.sendMessage(from, {
    edit: msgMedindoPau.key,
    text: `*Medindo o grossura do pau de* ${userTag} ğŸ«¸ğŸ«·ğŸ§`,
    mentions: [target]
  });
  await sleep(1500);
  await sock.sendMessage(from, {
    edit: msgMedindoPau.key,
    text: `*Espera ai q to medindoğŸ«¦* ${userTag} ğŸ«¸ ğŸ«· ğŸ¤”`,
    mentions: [target]
  });
  await sleep(1500);
  const tamanhopau = Math.floor(Math.random() * 30) + 1;
  const resultados = [
    {
      faixa: t => t <= 5,
      legenda: t => `*Kkkkk que dÃ³*\nâ‡’ ${userTag}\nSeu pau mede sÃ³ âœ®${t}cmâœ®\nChama o urologista kkk`,
      imagem: "https://i.postimg.cc/CMHCHrRF/20250704-192356.png"
    },
    {
      faixa: t => t > 5 && t <= 14,
      legenda: t => `*Rapaz...*\nâ‡’ ${userTag}\nSeu pau tem âœ®${t}cmâœ®\nTÃ¡ na mÃ©dia hein`,
      imagem: "https://files.catbox.moe/3snqji.jpg"
    },
    {
      faixa: t => t > 14 && t <= 24,
      legenda: t => `*Meu Deus do cÃ©u...*\nâ‡’ ${userTag}\nSeu pau tem âœ®${t}cmâœ®\nDesumilde demais!!!`,
      imagem: "https://i.postimg.cc/y6cVCDDL/20250706-151303.jpg"
    },
    {
      faixa: t => t >= 25,
      legenda: t => `*QUE ISSO MONSTRO??*\nâ‡’ ${userTag}\nSeu pau tem absurdos âœ®${t}cmâœ®\nIsso nem Ã© humano mais kkkk`,
      imagem: "https://files.catbox.moe/7i4u1l.png"
    }
  ];
  const resultado = resultados.find(r => r.faixa(tamanhopau));
  const legendaPau = resultado.legenda(tamanhopau);
  const imagemPau = resultado.imagem;
  const imageBuffer = await axios.get(imagemPau, { responseType: 'arraybuffer' }).then(res => res.data);
  await sock.sendMessage(from, {
    image: imageBuffer,
    caption: legendaPau,
    mentions: [target]
  }, { quoted: msg });
}

else if (isGroup && /^safada\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant || (mentionedJid.length > 0 ? mentionedJid[0] : sender);
  const userTag = `@${target.split('@')[0]}`;

    await sock.sendMessage(from, {
      react: {
        text: 'ğŸ”¥',
        key: msg.key
      }
    });


  // Gera a porcentagem aleatÃ³ria
  const porcentagem = Math.floor(Math.random() * 100) + 1;

  // Determina o vÃ­deo com base na porcentagem
  let videoPath = '';
  if (porcentagem >= 1 && porcentagem <= 19) videoPath = './dados/figurinhas/safada1.mp4';
  else if (porcentagem >= 20 && porcentagem <= 29) videoPath = './dados/figurinhas/safada2.mp4';
  else if (porcentagem >= 30 && porcentagem <= 49) videoPath = './dados/figurinhas/safada3.mp4';
  else if (porcentagem >= 50 && porcentagem <= 59) videoPath = './dados/figurinhas/safada4.mp4';
  else if (porcentagem >= 60 && porcentagem <= 70) videoPath = './dados/figurinhas/safada5.mp4';
  else if (porcentagem >= 71 && porcentagem <= 100) videoPath = './dados/figurinhas/safada6.mp4';

  // Envia o vÃ­deo com autoplay (gifPlayback)
  await sock.sendMessage(from, {
    video: fs.readFileSync(videoPath),
    caption: `ğŸ” O nÃ­vel de *safadeza* de ${userTag} Ã© de *${porcentagem}%*! ğŸ˜³ğŸ”¥`,
    gifPlayback: true,
    mentions: [target]
  }, { quoted: msg });
}

else if (isGroup && /^([!.])?(matar|mata)\b/i.test(msgLower)) {
await sock.sendMessage(from, { react: { text: "ğŸ¤º", key: msg.key } });
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);
  const texto = target
    ? `ğŸ”ªâš”ï¸ @${sender.split('@')[0]} ğğ¥ğ¢ğ¦ğ¢ğ§ğ¨ğ® ğŸğ«ğ¢ğšğ¦ğğ§ğ­ğ @${target.split('@')[0]}! â˜ ï¸`
    : `âš”ï¸ @${sender.split('@')[0]} tentou matar o ar... mas nÃ£o acertou ninguÃ©m! ğŸ˜‚`;
  const links = [
    'https://files.catbox.moe/df1teu.mp4',
    'https://files.catbox.moe/ctzmqg.mp4',
    'https://files.catbox.moe/cgeqqw.mp4',
    'https://files.catbox.moe/iyyo7m.mp4',
    'https://files.catbox.moe/0r5aty.mp4'
  ];
  const linkAleatorio = links[Math.floor(Math.random() * links.length)];
  try {
    await sock.sendMessage(from, {
      video: { url: linkAleatorio },
      caption: texto,
      gifPlayback: true,
      mentions: target ? [sender, target] : [sender],
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando matar:", e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar executar o comando matar.'
    }, { quoted: msg });
  }
}
else if (isGroup && msgLower.startsWith('perfil')) {
  const infoDono = JSON.parse(fs.readFileSync('./dono/info.json'));
  const numeroDono = infoDono.numerodono + '@s.whatsapp.net';
  const isDono = sender === numeroDono;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
  if (mentionedJid && !isDono) {
    await sock.sendMessage(from, { text: 'ğŸš« Apenas o dono pode ver o perfil de outro usuÃ¡rio.' }, { quoted: msg });
    return;
  }
  const alvo = mentionedJid && isDono ? mentionedJid : sender;
  const userNumber = alvo.replace(/[^0-9]/g, '');
  const userId = userNumber + '@s.whatsapp.net';
  try {
    await sock.sendMessage(from, {
      react: {
        text: 'ğŸ™‡ğŸ»â€â™€ï¸',
        key: msg.key
      }
    });
  } catch (e) {
    console.error('Erro ao reagir Ã  mensagem:', e);
  }
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(userId, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/590tu5.jpg';
  }
  const thumbnailBuffer = await axios.get(ppUrl, { responseType: 'arraybuffer' }).then(res => res.data);
  let isAdminUser = false;
  try {
    const metadata = await sock.groupMetadata(from);
    const participant = metadata.participants.find(p => p.id === userId);
    isAdminUser = participant?.admin === 'admin' || participant?.admin === 'superadmin';
  } catch {}
  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
  let bio = 'ğ—¦ğ—²ğ—º ğ—¯ğ—¶ğ—¼';
  try {
    await sock.presenceSubscribe(userId);
    await delay(2000);
    const status = await sock.fetchStatus(userId);
    if (status?.[0]?.status?.status && status[0].status.status.trim()) {
      bio = status[0].status.status.trim();
    }
  } catch (err) {
    console.error('Erro ao buscar status:', err);
  }
  let mensagens = 0;
  try {
    const filePath = './dados/contador.json';
    if (fs.existsSync(filePath)) {
      const fileData = JSON.parse(fs.readFileSync(filePath));
      mensagens = fileData[from]?.[userId] || 0;
    }
  } catch (err) {
    console.error('Erro ao ler contagem de mensagens:', err);
  }
  const perfilText = `ğŸ‘¤ ğ—¨ğ˜€ğ˜‚ğ—®Ìğ—¿ğ—¶ğ—¼ @${userNumber}\n\nğŸ—’ï¸ ğ—•ğ—¶ğ—¼: ${bio}\nğŸ‘® ğ—”ğ—±ğ—ºğ—¶ğ—»: ${isAdminUser ? 'âœ…' : 'âŒ'}\nğŸ’¬ ğ— ğ—²ğ—»ğ˜€ğ—®ğ—´ğ—²ğ—»ğ˜€: ${mensagens}`;
  await sock.sendMessage(from, {
    text: perfilText,
    mentions: [userId],
    contextInfo: {
      mentionedJid: [userId],
      externalAdReply: {
        title: 'ğŸ‘¤ ğ—£ğ—˜ğ—¥ğ—™ğ—œğ—Ÿ ğ——ğ—¢ ğ—¨ğ—¦ğ—¨ğ—”Ìğ—¥ğ—œğ—¢',
        body: 'ğ˜´ğ˜¢ğ˜¯ğ˜ª ğ˜¥ğ˜°ğ˜®ğ˜ªğ˜¯ğ˜¢ ğŸ‘¾',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: true,
        sourceUrl: 'https://nexosofc'
      }
    }
  }, { quoted: msg });
}
// DOWNLOADS ///
else if (isGroup && /^([!.])?play\b/i.test(msg.message?.conversation?.toLowerCase() || '')) {
  const texto = msg.message.conversation.trim();
  const query = texto.slice(4).trim();
  if (!query) {
    await sock.sendMessage(from, { text: '*_VocÃª precisa enviar o nome da mÃºsica ou o link do YouTube._*' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { react: { text: "ğŸ¶", key: msg.key } });
  await sock.sendMessage(from, { text: '_*ğŸ”ğŸ’•Procurando Ã¡udio, aguarde...*_'}, { quoted: msg });
  let videoInfo;
  let videoUrl = '';
  if (query.includes('youtu')) {
    videoUrl = query;
    const videoId = videoUrl.split('v=')[1]?.split('&')[0];
    const results = await yts(videoId);
    videoInfo = results.videos[0];
  } else {
    try {
      const results = await yts(query);
      if (!results || !results.videos.length) {
        await sock.sendMessage(from, { text: 'âŒ Nenhum resultado encontrado no YouTube.' }, { quoted: msg });
        return;
      }
      videoInfo = results.videos[0];
      videoUrl = videoInfo.url;
    } catch (e) {
      console.error('Erro na busca do YouTube:', e);
      await sock.sendMessage(from, { text: 'âŒ Erro ao buscar no YouTube.' }, { quoted: msg });
      return;
    }
  }
  let agoPt = videoInfo.ago || '';
  agoPt = agoPt
    .replace('years ago', 'anos atrÃ¡s')
    .replace('year ago', 'ano atrÃ¡s')
    .replace('months ago', 'meses atrÃ¡s')
    .replace('month ago', 'mÃªs atrÃ¡s')
    .replace('days ago', 'dias atrÃ¡s')
    .replace('day ago', 'dia atrÃ¡s')
    .replace('hours ago', 'horas atrÃ¡s')
    .replace('hour ago', 'hora atrÃ¡s')
    .replace('minutes ago', 'minutos atrÃ¡s')
    .replace('minute ago', 'minuto atrÃ¡s');
  const legenda = `*_ğŸŒ¸ğ‘©ğ‘¨ğ‘°ğ‘¿ğ‘¨ğ‘µğ‘«ğ‘¶ğŸ¶ğ‘¨ğ‘¼ğ‘«ğ‘°ğ‘¶ğŸ’•..._*\n`;
  await sock.sendMessage(from, {
    text: legenda + videoUrl,
    contextInfo: {
      externalAdReply: {
        showAdAttribution: true,
        mediaType: 2,
        title: videoInfo.title,
        body: `ğŸ‘€ ${videoInfo.views.toLocaleString()} â€¢ ğŸ•’ ${videoInfo.timestamp} â€¢ ğŸ“… ${agoPt}`,
        thumbnailUrl: videoInfo.thumbnail,
        mediaUrl: videoUrl,
        sourceUrl: videoUrl
      }
    }
  }, { quoted: msg });

  await new Promise(resolve => setTimeout(resolve, 2500));
  const id = Date.now();
  const output = `/storage/emulated/0/Download/audio_${id}.mp3`;
  exec(`yt-dlp --no-playlist --no-warnings --no-call-home --no-check-certificate --ignore-errors --no-overwrites -x --audio-format mp3 --cookies "/storage/D72F-0D01/Download/SanizinhaBot/dados/cookies/youtube.com_cookies.txt" -o "${output}" "${videoUrl}"`, async (err, stdout, stderr) => {
    console.log('YT-DLP STDERR:', stderr);
    console.log('YT-DLP STDOUT:', stdout);

    if (!fs.existsSync(output)) {
      console.error('Erro ao baixar Ã¡udio:', err || stderr);
      await sock.sendMessage(from, {
        text: 'âŒO vÃ­deo tem restriÃ§Ã£o de idadeğŸ™ caso queira atualizar os cookies digite infocookie',
        quoted: msg
      });
      return;
    }
    const caption =
      `ğŸµ *${videoInfo.title}*\n` +
      `ğŸ•’ DuraÃ§Ã£o: *${videoInfo.timestamp}*\n` +
      `ğŸ‘€ VisualizaÃ§Ãµes: *${videoInfo.views.toLocaleString()}*\n` +
      `ğŸ“… Publicado: *${agoPt}*\n` +
      `ğŸ”— ${videoInfo.url}`;

    await sock.sendMessage(from, {
      audio: { url: output },
      mimetype: 'audio/mpeg',
      ptt: false,
      caption: caption
    }, { quoted: msg });

    setTimeout(() => {
      try {
        fs.unlinkSync(output);
        console.log(`Arquivo apagado: ${output}`);
      } catch (e) {
        console.error('Erro ao apagar o arquivo:', e);
      }
    }, 10000);
  });
}

else if (isGroup && msg.message?.conversation?.toLowerCase().startsWith('playvd')) {
  const texto = msg.message.conversation.trim();
  const query = texto.slice(4).trim();
  if (!query) {
    await sock.sendMessage(from, { text: '*_VocÃª precisa enviar o nome da mÃºsica ou o link do YouTube._*' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { react: { text: "ğŸ“¹", key: msg.key } });
  await sock.sendMessage(from, { text: '_*ğŸ”ğŸ’•Procurando vÃ­deo, aguarde...*_' }, { quoted: msg });
  let videoInfo;
  let videoUrl = '';
  if (query.includes('youtu')) {
    videoUrl = query;
    const videoId = videoUrl.split('v=')[1]?.split('&')[0];
    const results = await yts(videoId);
    videoInfo = results.videos[0];
  } else {
    try {
      const results = await yts(query);
      if (!results || !results.videos.length) {
        await sock.sendMessage(from, { text: 'âŒ Nenhum resultado encontrado no YouTube.' }, { quoted: msg });
        return;
      }
      videoInfo = results.videos[0];
      videoUrl = videoInfo.url;
    } catch (e) {
      console.error('Erro na busca do YouTube:', e);
      await sock.sendMessage(from, { text: 'âŒ Erro ao buscar no YouTube.' }, { quoted: msg });
      return;
    }
  }
  let agoPt = videoInfo.ago || '';
  agoPt = agoPt
    .replace('years ago', 'anos atrÃ¡s')
    .replace('year ago', 'ano atrÃ¡s')
    .replace('months ago', 'meses atrÃ¡s')
    .replace('month ago', 'mÃªs atrÃ¡s')
    .replace('days ago', 'dias atrÃ¡s')
    .replace('day ago', 'dia atrÃ¡s')
    .replace('hours ago', 'horas atrÃ¡s')
    .replace('hour ago', 'hora atrÃ¡s')
    .replace('minutes ago', 'minutos atrÃ¡s')
    .replace('minute ago', 'minuto atrÃ¡s');
  const legenda = `*_ğŸŒ¸ğ‘ºğ’‚ğ’ğ’Šğ’›ğ’Šğ’ğ’‰ğ’‚ ğ‘©ğ’ğ’•ğŸ’•_*\n`;
  await sock.sendMessage(from, {
    text: legenda + videoUrl,
    contextInfo: {
      externalAdReply: {
        showAdAttribution: true,
        mediaType: 2,
        title: videoInfo.title,
        body: `ğŸ‘€ ${videoInfo.views.toLocaleString()} â€¢ ğŸ•’ ${videoInfo.timestamp} â€¢ ğŸ“… ${agoPt}`,
        thumbnailUrl: videoInfo.thumbnail,
        mediaUrl: videoUrl,
        sourceUrl: videoUrl
      }
    }
  }, { quoted: msg });
}

else if (isGroup && /^([!.])?(videopraaudio|vdpraau)$/i.test(msgLower)) {
  if (!msg.message?.videoMessage && !msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage) {
    await sock.sendMessage(from, { text: 'âŒ Envie ou responda a um vÃ­deo para extrair o Ã¡udio.' }, { quoted: msg });
    return;
  }
 await sock.sendMessage(from, { react: { text: "ğŸ¼", key: msg.key } });  
  const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage || msg.message;
  const video = quoted.videoMessage;
  const mediaBuffer = await downloadMediaMessage({ message: { videoMessage: video } }, 'buffer', {}, { logger, reuploadRequest: sock.updateMediaMessage });
  const tmpInput = './tmpvideo.mp4';
  const tmpOutput = './tmpaudio.mp3';
 fs.writeFileSync(tmpInput, mediaBuffer);
  ffmpeg(tmpInput)
    .format('mp3')
    .audioCodec('libmp3lame')
    .on('end', async () => {
      const audio = fs.readFileSync(tmpOutput);
      await sock.sendMessage(from, { audio: audio, mimetype: 'audio/mp4' }, { quoted: msg });
      fs.unlinkSync(tmpInput);
      fs.unlinkSync(tmpOutput);
    })
    .on('error', async (err) => {
      console.error('Erro ao converter:', err);
      await sock.sendMessage(from, { text: 'âŒ Erro ao converter o vÃ­deo para Ã¡udio.' }, { quoted: msg });
      fs.unlinkSync(tmpInput);
    })
    .save(tmpOutput);
}

 // RANKS  // RANCKGAY
 else if (isGroup && msgLower === 'rankgay') {
   try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
 try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank gay.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesZoeira = (porc) => {
      if (porc >= 90) return 'ğŸŒˆ Esse aqui jÃ¡ tÃ¡ marchando na Parada Gay com glitter na cara e cropped da Barbie!';
      if (porc >= 75) return 'ğŸ’… Vive de shortinho curto ouvindo Pabllo Vittar no talo.';
      if (porc >= 50) return 'ğŸ˜ JÃ¡ deu uma rebolada pro amigo e gostou.';
      if (porc >= 25) return 'ğŸ¤¨ Fala que Ã© hÃ©tero, mas assiste BBB com crush no Fred.';
      return 'ğŸ§¢ Esse jura que Ã© hÃ©tero, mas passa pano pra cada macho feio...';
    };
    let texto = 'ğŸ³ï¸â€ğŸŒˆ *RANKING GAY OFICIAL DO GRUPO* ğŸ³ï¸â€ğŸŒˆ\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% GAY*\n_${frasesZoeira(porc)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/DybPg2Z6/images-1.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankgay:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank gay.',
    }, { quoted: msg });
  }
}
 
 else if (isGroup && (msgLower === 'rankppk' || msgLower === 'rankbuceta')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ’•', key: msg.key } });
  } catch {} 
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking da buceta.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const frasesPpk = (tam) => {
      if (tam <= 5) return 'ğŸ§ƒ Entrou sÃ³ a pontinha e jÃ¡ reclamou de dor ğŸ˜¬';
      if (tam <= 10) return 'ğŸ”’ Apertadinha... sÃ³ entra se pedir licenÃ§a primeiro!';
      if (tam <= 15) return 'ğŸ‘… Cabe o bot, o admin e ainda sobra espaÃ§o pra um milkshake';
      if (tam <= 20) return 'ğŸŒªï¸ JÃ¡ virou parque de diversÃ£o do bairro';
      if (tam <= 30) return 'ğŸš¨ Qualquer coisa que entra ali precisa de resgate';
      return 'ğŸ˜ Isso aÃ­ Ã© o *multiverso da buceta*! JÃ¡ moram 3 famÃ­lias ali dentro';
    };
    let texto = 'ğŸ’¦ *TOP 5 PPKAS DO GRUPOğŸ˜‚* ğŸ’¦\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const tamanho = Math.floor(Math.random() * 35) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ’‹ ${tag} â€” *${tamanho}cm de PPK*\n_${frasesPpk(tamanho)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/0yS6FjRW/images-4.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankPpk:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Deu erro ao montar o ranking bucetudo.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankpau' || msgLower === 'pau')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸªµ', key: msg.key } });
  } catch {}
    
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking do PAU.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const frasesPau = (tam) => {
      if (tam <= 8) return 'ğŸ”Œ VersÃ£o USB... sÃ³ conecta se for com carinho';
      if (tam <= 14) return 'ğŸŒ ClÃ¡ssico nacional, padrÃ£o mÃ©dio';
      if (tam <= 20) return 'ğŸš€ Pau fogueteiro, jÃ¡ foi atÃ© pra NASA';
      if (tam <= 30) return 'ğŸª“ Esse aÃ­ tem CPF prÃ³prio e paga imposto';
      if (tam <= 40) return 'Famoso espanca ÃºterosğŸ˜‚';
      return 'ğŸ² O dragÃ£o acordou, se esconde que Ã© tsunami';
    };
    let texto = 'ğŸ† *TOP 5 PAUZUDOS DO GRUPO* ğŸ†\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const tamanho = Math.floor(Math.random() * 48) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸŒ ${tag} â€” *${tamanho}cm de PAU*\n_${frasesPau(tamanho)}_\n\n`;
    }
    await sock.sendMessage(from, {
      video: { url: 'https://i.postimg.cc/xTx7hjyz/1509487127222.gif' },
      caption: texto.trim(),
      gifPlayback: true,
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankpau:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Deu erro ao montar o ranking paududo.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankputa' || msgLower === 'puta')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ’…ğŸ»', key: msg.key } });
  } catch {}    
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking da putaria.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const frasePutaria = (p) => {
      if (p <= 20) return 'ğŸš« Ainda assiste desenho da Barbie';
      if (p <= 40) return 'ğŸ˜‡ SÃ³ manda nude por engano (ou serÃ¡ que nÃ£o?)';
      if (p <= 60) return 'ğŸ”¥ JÃ¡ caiu na tentaÃ§Ã£o algumas vezes...';
      if (p <= 80) return 'ğŸ‘… Boca de 09h Ã s 18h e xereca de plantÃ£o';
      if (p < 100) return 'ğŸ‘ P*ta licenciada pelo MEC';
      return 'ğŸ‘‘ Rainha da putaria. Tem mais currÃ­culo que atriz pornÃ´';
    };
    let texto = 'ğŸ’‹ *TOP 5 MAIS PUTAS DO GRUPO* ğŸ’‹\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const porcentagem = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ’„ ${tag} â€” *${porcentagem}% puta*\n_${frasePutaria(porcentagem)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/KzGDmBmv/images-5.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro no comando rankputa:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o ranking das putas.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankclt' || msgLower === 'clt')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ‘·ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking CLT.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const fraseCLT = (p) => {
      if (p <= 20) return 'ğŸ˜ Trabalha por aplicativo e vive pedindo Pix';
      if (p <= 40) return 'ğŸš¨ JÃ¡ foi demitido por "reduÃ§Ã£o de custos" 3 vezes';
      if (p <= 60) return 'ğŸ“ Tem crachÃ¡ mas o salÃ¡rio mal paga o aluguel';
      if (p <= 80) return 'â˜• Vive de cafÃ© e reuniÃ£o que podia ser um e-mail';
      if (p < 100) return 'ğŸª™ Passa mais tempo no RH do que na prÃ³pria casa kkkk';
      return 'ğŸ‘” CLT raiz: sonha com fÃ©rias, acorda com despertador e vive pelo 13Âº';
    };
    let texto = 'ğŸ—ƒï¸ *TOP 5 MAIS CLT DO GRUPO* ğŸ—ƒï¸\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const porcentagem = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ§¾ ${tag} â€” *${porcentagem}% CLT*\n_${fraseCLT(porcentagem)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/13KK2vZY/images-6.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankclt:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o ranking CLT.',
    }, { quoted: msg });
  }
}
 
 else if (isGroup && msgLower === 'rankcorno') {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ‚', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank corno.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);

    const frasesCornudo = (porc) => {
      if (porc >= 90) return 'ğŸ«  JÃ¡ tÃ¡ criando chifre em casa e chamando de antena 5G.';
      if (porc >= 75) return 'ğŸ˜­ Sabe que Ã© corno e ainda paga o iFood pro RicardÃ£o.';
      if (porc >= 50) return 'ğŸ˜¢ Leva chifre e ainda pede desculpa.';
      if (porc >= 25) return 'ğŸ§ Ouvinte fiel do Pablo do Arrocha... sinal de alerta!';
      return 'ğŸ˜ AtÃ© agora tÃ¡ ileso... mas o RicardÃ£o jÃ¡ mandou solicitaÃ§Ã£o no Insta.';
    };

    let texto = 'ğŸ® *RANKING CORNO OFICIAL DO GRUPO* ğŸ®\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];

    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% CORNO*\n_${frasesCornudo(porc)}_\n\n`;
    }

    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/28mn4nsk/images-2.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro no comando rankcorno:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank corno.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankgado' || msgLower === 'rankgados')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ®', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank gado.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesGado = (porc) => {
      if (porc >= 90) return 'ğŸ„ Aceita atÃ© ser chamado de â€œamiguinhoâ€ por quem ama.';
      if (porc >= 75) return 'ğŸ¤§ Gasta Pix com quem nem visualiza as mensagens.';
      if (porc >= 50) return 'ğŸ«  Sabe que Ã© gado e ainda leva flores pra crush.';
      if (porc >= 25) return 'ğŸ«¥ Stalkeia story e chora no banho com MarÃ­lia MendonÃ§a.';
      return 'ğŸ§  Ainda tem salvaÃ§Ã£o, mas cuidado com as armadilhas do coraÃ§Ã£o.';
    };
    let texto = 'ğŸ’˜ *RANKING GADO ILUDIDO DO GRUPO* ğŸ’˜\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% GADO*\n_${frasesGado(porc)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/J44GrKwk/images-3.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankgado:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank gado.',
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'ranklindo') {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ˜', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank lindo.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesLindeza = (porc) => {
      if (porc >= 90) return 'ğŸŒŸ TÃ£o lindo que atÃ© o espelho se apaixona.';
      if (porc >= 75) return 'âœ¨ Um charme que derruba forninhos.';
      if (porc >= 50) return 'ğŸ˜ Bonitinhoâ€¦ de longe.';
      if (porc >= 25) return 'ğŸ™‚ Tem dias melhores, mas a autoestima segue firme.';
      return 'ğŸ«£ Quebra atÃ© a cÃ¢mera frontal com esse rostinho.';
    };
    let texto = 'ğŸŒŸ *TOP 5 MAIS LINDOS DO GRUPO* ğŸŒŸ\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% LINDO*\n_${frasesLindeza(porc)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/J4ZMWk0k/3ee22857e7e927bcd89b9ead6f4274b0.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando ranklindo:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank lindo.',
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'rankfeio') {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ‘¹', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking da feiura.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesFeiura = (porc) => {
      if (porc >= 90) return 'ğŸ‘º Feio Ã© pouco, isso aÃ­ foi esculpido na raiva!';
      if (porc >= 75) return 'ğŸ§Ÿâ€â™‚ï¸ Parece que caiu da Ã¡rvore da feiura e bateu em todos os galhos.';
      if (porc >= 50) return 'ğŸ˜¬ Um charme... pra espantar assombraÃ§Ã£o.';
      if (porc >= 25) return 'ğŸ¤” Meio esquisito, mas tem quem goste.';
      return 'ğŸ˜‡ Quase bonito... mas o "quase" Ã© eterno.';
    };
    let texto = 'ğŸ’€ *TOP 5 MAIS FEIOS DO GRUPO* ğŸ’€\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% FEIO*\n_${frasesFeiura(porc)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/d1gPbsK6/c7510282d6fcc455b5784cb46000f9d7.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankfeio:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Deu erro ao montar o ranking da feiura.',
    }, { quoted: msg });
  }
}
 // FIM DOS RANKS
// interaÃ§Ã£o bot
else if (isGroup && (msgLower === 'bot' || msgLower === 'sanizinha')) {
  const user = sender;
  const now = Date.now();
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ’—', key: msg.key } });
  } catch {}
  if (muteBotUsers.has(user)) return;
  if (!spamBotMap.has(user)) spamBotMap.set(user, []);
  const timestamps = spamBotMap.get(user).filter(ts => now - ts < 10000);
  timestamps.push(now);
  spamBotMap.set(user, timestamps);
  if (timestamps.length >= 3) {
    muteBotUsers.add(user);
    setTimeout(() => muteBotUsers.delete(user), 10 * 60 * 1000);
    await sock.sendMessage(from, { text: 'porra tu Ã© chato pra carai, fala cmg nÃ£o.' }, { quoted: msg });
    await sock.sendMessage(from, {
      sticker: { url: './dados/figurinhas/fdp.webp' }
    }, { quoted: msg });
  } else {
    await sock.sendMessage(from, { text: `oi @${user.split('@')[0]}, se quiser ver o menu Ã© sÃ³ mandar *menu*`, mentions: [user] }, { quoted: msg });
    await sock.sendMessage(from, {
      sticker: { url: './dados/figurinhas/bot.webp' }
    }, { quoted: msg });
  }
  return;
}
 
else if (isGroup && msgLower === 'eu te amo sanizinha') {
  const user = sender;
  const now = Date.now();

  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ’—', key: msg.key } });
  } catch {}

  if (muteBotUsers.has(user)) return;

  if (!spamBotMap.has(user)) spamBotMap.set(user, []);
  const timestamps = spamBotMap.get(user).filter(ts => now - ts < 10000);
  timestamps.push(now);
  spamBotMap.set(user, timestamps);

  if (timestamps.length >= 3) {
    muteBotUsers.add(user);
    setTimeout(() => muteBotUsers.delete(user), 10 * 60 * 1000); // 10 minutos

    await sock.sendMessage(from, { text: 'acalma o coraÃ§Ã£o kkkğŸ¤­' }, { quoted: msg });
    await sock.sendMessage(from, {
      sticker: { url: './dados/figurinhas/acalma.webp' }
    }, { quoted: msg });
  } else {
    await sock.sendMessage(from, {
      text: `own @${user.split('@')[0]} *eu tambÃ©m te amoğŸ’—*`,
      mentions: [user]
    }, { quoted: msg });

    await sock.sendMessage(from, {
      sticker: { url: './dados/figurinhas/teamo.webp' }
    }, { quoted: msg });
  }
  return;
} 
 
 // JOGOS
 else if (isGroup && /^dado$/i.test(msgLower)) {
  try {
    const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
    const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
    const target = quotedParticipant || (mentionedJid.length > 0 ? mentionedJid[0] : sender);
    const userTag = `@${target.split('@')[0]}`;
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ²", msg), 300);
    }
    const dadoImages = [
      { url: "https://i.ibb.co/zmVD85Z/53025f3f00f8.webp", no: 6 },
      { url: "https://i.ibb.co/BchBsJ1/0b7b4a9b811d.webp", no: 5 },
      { url: "https://i.ibb.co/25Pf1sY/a66d2b63f357.webp", no: 4 },
      { url: "https://i.ibb.co/hccTrhd/5b36dd6442b8.webp", no: 3 },
      { url: "https://i.ibb.co/9tPHPDt/544dbba5bb75.webp", no: 2 },
      { url: "https://i.ibb.co/y040HHw/3e583d6459e6.webp", no: 1 }
    ];
    const resultado = dadoImages[Math.floor(Math.random() * dadoImages.length)];
    await sock.sendMessage(from, {
      text: `ğŸ² Jogando o dado para ${userTag}...`,
      mentions: [target]
    }, { quoted: msg });
    await sleep(1000);
    await sock.sendMessage(from, {
      sticker: { url: resultado.url }
    }, { quoted: msg });
    await sock.sendMessage(from, {
      text: `ğŸ² O dado caiu no nÃºmero *${resultado.no}*!`,
      mentions: [target]
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro ao executar comando dado:", e);
    await sock.sendMessage(from, { text: "âŒ Ocorreu um erro ao jogar o dado." }, { quoted: msg });
  }
}

 // Iniciar jogo da velha
else if (msgLower.startsWith('jogodavelha') || msgLower.startsWith('jv')) {
  if (jogoVelha.jogos[from]) {
    await sock.sendMessage(from, { text: 'âš ï¸ JÃ¡ existe um jogo em andamento.' }, { quoted: msg });
    return;
  }
  if (msgLower.includes('bot')) {
    jogoVelha.criarNovoJogo(from, sender, 'bot', true);
    await sock.sendMessage(from, { text: `ğŸ® *Jogo da Velha iniciado contra o Bot!*\n${jogoVelha.jogar(from, sender, 0)}` }, { quoted: msg });
  } else {
    const mencionado = msg.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
    if (!mencionado) {
      await sock.sendMessage(from, { text: 'ğŸ‘¥ Marque alguÃ©m para jogar contra ou use "jv bot" para jogar contra o bot.' }, { quoted: msg });
      return;
    }
    if (mencionado === sender) {
      await sock.sendMessage(from, { text: 'âŒ VocÃª nÃ£o pode jogar contra si mesmo.' }, { quoted: msg });
      return;
    }
    jogoVelha.criarNovoJogo(from, sender, mencionado);
    await sock.sendMessage(from, { text: `ğŸ® *Jogo da Velha iniciado!*\n${jogoVelha.jogar(from, sender, 0)}` }, { quoted: msg });
  }
}

// Jogada
else if (msgLower.match(/^[1-9]$/) && jogoVelha.jogos[from]) {
  const resultado = jogoVelha.jogar(from, sender, msgLower);
  await sock.sendMessage(from, { text: resultado }, { quoted: msg });
  // Se acabou, remove
  if (!jogoVelha.jogos[from].jogando) {
    delete jogoVelha.jogos[from];
  }
}

// Iniciar jogo campo minado
else if (msgLower === 'campominado' || msgLower === 'cm') {
  if (campominado.jogos[from]) {
    await sock.sendMessage(from, { text: 'âš ï¸ JÃ¡ existe um jogo em andamento neste chat.' }, { quoted: msg });
    return;
  }
  campominado.iniciarJogo(from, sender);
  await sock.sendMessage(from, { text: `ğŸ§¨ *Campo Minado Iniciado!*\nDigite algo como *b2* ou *g5* para jogar.\n\n${campominado.jogar(from, sender, 'a1')}` }, { quoted: msg });
}

// Jogadas no formato a1, h8, etc.
else if (/^[a-h][1-8]$/i.test(msgLower) && campominado.jogos[from]) {
  const resposta = campominado.jogar(from, sender, msgLower);
  await sock.sendMessage(from, { text: resposta }, { quoted: msg });
}

// memoria
if (isGroup && msg.message?.extendedTextMessage?.text?.toLowerCase().startsWith('memoria')) {
  const mentioned = msg.message.extendedTextMessage.contextInfo?.mentionedJid?.[0];
  if (!mentioned) return sock.sendMessage(from, { text: 'ğŸ‘¤ Marque um usuÃ¡rio para jogar contra vocÃª.' }, { quoted: msg });
  if (memoria.jogadores[from]) return sock.sendMessage(from, { text: 'âš ï¸ JÃ¡ existe um jogo em andamento.' }, { quoted: msg });
  memoria.iniciarJogo(from, sender, mentioned);
  const jogo = memoria.jogadores[from];
  await sock.sendMessage(from, {
    text: `ğŸ§  *Jogo da MemÃ³ria iniciado!*\n\nğŸ® Jogadores:\n@${sender.split('@')[0]}\n@${mentioned.split('@')[0]}\n\nğŸ¯ ComeÃ§a @${sender.split('@')[0]}\n\n${mostrarTabuleiro(jogo)}`,
    mentions: [sender, mentioned]
  }, { quoted: msg });
}
// Jogadas: "1 5"
else if (/^\d+\s+\d+$/.test(text) && memoria.jogadores[from]) {
  const resultado = memoria.jogar(from, sender, text.trim());
  if (resultado.fim) {
    await sock.sendMessage(from, {
      text: resultado.texto,
      mentions: resultado.mentions
    }, { quoted: msg });
  } else if (typeof resultado === 'string') {
    await sock.sendMessage(from, { text: resultado }, { quoted: msg });
  } else {
    const msgResposta = await sock.sendMessage(from, {
      text: resultado.texto,
      mentions: resultado.mentions
    }, { quoted: msg });
    setTimeout(async () => {
      const texto = resultado.esconder();
      await sock.sendMessage(from, {
        text: texto,
        mentions: resultado.mentions
      });
    }, 4000);
  }
}
// verdade ou desafio
if (isGroup && /^([!.])?vdddsf\b/i.test(msgLower)) {
  const filePath = './dados/vdddsf.json';
  if (!fs.existsSync(filePath)) {
    await sock.sendMessage(from, { text: 'âŒ Arquivo vdddsf.json nÃ£o encontrado.' }, { quoted: msg });
    return;
  }
  try {
    const perguntas = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    if (!Array.isArray(perguntas) || perguntas.length === 0) {
      await sock.sendMessage(from, { text: 'âŒ Nenhuma pergunta encontrada no vdddsf.json.' }, { quoted: msg });
      return;
    }
    const perguntaAleatoria = perguntas[Math.floor(Math.random() * perguntas.length)];
    await sock.sendMessage(from, {
      poll: {
        name: `ğŸ§  ${perguntaAleatoria}`,
        values: ['âœ… Sim', 'âŒ NÃ£o'],
        selectableCount: 1
      }
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro ao ler vdddsf.json:', e);
    await sock.sendMessage(from, { text: 'âŒ Erro ao processar o arquivo vdddsf.json.' }, { quoted: msg });
  }
}

// Iniciar o jogo da forca
if (msgLower.startsWith('forca')) {
    if (forca.jogos[from]) {
      await sock.sendMessage(from, { text: 'âš ï¸ JÃ¡ existe um jogo da Forca em andamento.' }, { quoted: msg });
      return;
    }

    if (msgLower.includes('bot')) {
      forca.criarNovoJogo(from, sender, 'bot');
      await sock.sendMessage(from, { text: `ğŸ® *Jogo da Forca iniciado contra o Bot!*\n${forca.jogar(from, sender, '')}` }, { quoted: msg });
    } else {
      const mencionado = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
      if (!mencionado) {
        await sock.sendMessage(from, { text: 'ğŸ‘¥ Marque alguÃ©m para jogar ou use "forca bot" para jogar contra o bot.' }, { quoted: msg });
        return;
      }
      if (mencionado === sender) {
        await sock.sendMessage(from, { text: 'âŒ VocÃª nÃ£o pode jogar contra si mesmo.' }, { quoted: msg });
        return;
      }
      forca.criarNovoJogo(from, sender, mencionado);
      await sock.sendMessage(from, { text: `ğŸ® *Jogo da Forca iniciado!*\n${forca.jogar(from, sender, '')}` }, { quoted: msg });
    }
  } else if (forca.jogos[from] && /^[a-zA-Z]{1,20}$/.test(msgLower)) {
    const resultado = forca.jogar(from, sender, msgLower);
    await sock.sendMessage(from, { text: resultado }, { quoted: msg });

    if (!forca.jogos[from].jogando) {
      delete forca.jogos[from];
    }
  }
// FIM DOS JOGOS //

else if (msgLower === 'reiniciar') {
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const infoDono = JSON.parse(fs.readFileSync('./dono/info.json'));
  const numeroDono = infoDono.numerodono + '@s.whatsapp.net';
  if (sender !== numeroDono) {
    await sock.sendMessage(from, { text: 'ğŸš« Apenas o dono pode reiniciar o bot.' }, { quoted: msg });
    return;
  }
  let porcentagem = 0;
  const barra = (porcentagem) => {
    const total = 20;
    const preenchido = Math.round((porcentagem / 100) * total);
    const vazio = total - preenchido;
    return `[${'â–ˆ'.repeat(preenchido)}${'â–‘'.repeat(vazio)}] ${porcentagem}%`;
  };
  const mensagem = await sock.sendMessage(from, { text: ` .....\n${barra(porcentagem)}` }, { quoted: msg });
  const interval = setInterval(async () => {
    porcentagem += 10;
    if (porcentagem > 100) porcentagem = 100;
    await sock.sendMessage(from, {
      text: `*ğŸ’•ğ˜™ğ˜¦ğ˜ªğ˜¯ğ˜ªğ˜¤ğ˜ªğ˜¢ğ˜¯ğ˜¥ğ˜° ğ˜´ğ˜¢ğ˜¯ğ˜ªğ˜»ğ˜ªğ˜¯ğ˜©ğ˜¢ à¸…â‰½^â€¢â©Šâ€¢^â‰¼à¸…*\n${barra(porcentagem)}`,
      edit: mensagem.key
    });
    if (porcentagem === 100) {
      clearInterval(interval);
      await new Promise(res => setTimeout(res, 1000));
      process.exit(0);
    }
  }, 400);
}


else if (msgLower.startsWith('bloock')) {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderNum = sender.split('@')[0].replace(/\D/g, '');
  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  const args = msg.message.conversation.split(' ');
  if (args.length < 2) {
    await sock.sendMessage(from, { text: 'âŒ Por favor, informe o nÃºmero para bloquear.\nExemplo: block 5511999999999' }, { quoted: msg });
    return;
  }
  const numeroAlvo = args[1].replace(/\D/g, '');
  if (!numeroAlvo) {
    await sock.sendMessage(from, { text: 'âŒ NÃºmero invÃ¡lido.' }, { quoted: msg });
    return;
  }
  const bloqueados = carregarBloqueados();
  const jidAlvo = numeroAlvo + '@s.whatsapp.net';
  if (bloqueados.includes(jidAlvo)) {
    await sock.sendMessage(from, { text: '*Este nÃºmero jÃ¡ estÃ¡ bloqueado.*' }, { quoted: msg });
    return;
  }
  bloqueados.push(jidAlvo);
  salvarBloqueados(bloqueados);
  await sock.sendMessage(from, { text: `*NÃºmero @${numeroAlvo} bloqueado para nao usar o botğŸ¥²*.`, mentions: [jidAlvo] }, { quoted: msg });
}
else if (msgLower.startsWith('unbloock')) {
  const infoDono = JSON.parse(fs.readFileSync('./dono/info.json'));
  const dono = infoDono.numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (senderSemDDD !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar.' }, { quoted: msg });
    return;
  }
  const numeroAlvo = body.split(' ')[1]?.replace(/\D/g, '');
  if (!numeroAlvo) {
    await sock.sendMessage(from, { text: 'âŒ Informe o nÃºmero para desbloquear. Ex: unblock 5511999999999' }, { quoted: msg });
    return;
  }
  const jid = numeroAlvo + '@s.whatsapp.net';
  let bloqueados = carregarBloqueados();
  if (!bloqueados.includes(jid)) {
    await sock.sendMessage(from, { text: '*Este nÃºmero nÃ£o estÃ¡ bloqueado.*' }, { quoted: msg });
    return;
  }
  bloqueados = bloqueados.filter(num => num !== jid);
  salvarBloqueados(bloqueados);
  await sock.sendMessage(from, {
    text: ` *NÃºmero @${numeroAlvo} desbloqueadoğŸ¥³*.`,
    mentions: [jid]
  }, { quoted: msg });
}

else if (msgLower === 'listblock') {
  const infoDono = JSON.parse(fs.readFileSync('./dono/info.json'));
  const dono = infoDono.numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (senderSemDDD !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode ver a lista de bloqueados.' }, { quoted: msg });
    return;
  }
  let bloqueados = carregarBloqueados();
  if (bloqueados.length === 0) {
    await sock.sendMessage(from, { text: 'âœ… Nenhum nÃºmero estÃ¡ bloqueado.' }, { quoted: msg });
    return;
  }
  const lista = bloqueados.map((jid, i) => `${i + 1}. @${jid.replace(/@s\.whatsapp\.net$/, '')}`).join('\n');
  await sock.sendMessage(from, {
    text: `ğŸ“› Lista de bloqueados:\n\n${lista}`,
    mentions: bloqueados
  }, { quoted: msg });
}

else if (isGroup && msgLower === 'antitrava') {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem ativar ou desativar o AntiTrava.' }, { quoted: msg });
    return;
  }
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  
  const configPath = `./dados/grupos/${from}.json`;
  let configGrupo = {};
  if (fs.existsSync(configPath)) {
    configGrupo = JSON.parse(fs.readFileSync(configPath));
  }
  configGrupo.antitrava = !configGrupo.antitrava;
  fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
  const status = configGrupo.antitrava ? 'ativado' : 'desativado';
  await sock.sendMessage(from, {
    text: `ğŸ›¡ï¸ Sistema AntiTrava ${status} ğŸ–– ğ—”ğ˜ƒğ—¶ğ˜€ğ—² ğ—®ğ—¼ğ˜€ ğ—ºğ—²ğ—ºğ—¯ğ—¿ğ—¼ğ˜€ ğ˜ğ—¼ğ—ºğ—®ğ—¿ ğ—°ğ˜‚ğ—¶ğ—±ğ—®ğ—±ğ—¼ ğ—°ğ—¼ğ—º ğ—ºğ—²ğ—»ğ˜€ğ—®ğ—´ğ—²ğ—»ğ˜€ ğ—ºğ˜‚ğ—¶ğ˜ğ—¼ ğ—¹ğ—¼ğ—»ğ—´ğ—®ğ˜€ğŸ˜¹!`
  }, { quoted: msg });
}

  else if (isGroup && msgLower === 'antilink') {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem ativar ou desativar o AntiLink.' }, { quoted: msg });
    return;
  }
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  
  const configPath = `./dados/grupos/${from}.json`;
  let configGrupo = {};
  if (fs.existsSync(configPath)) {
    configGrupo = JSON.parse(fs.readFileSync(configPath));
  }
  configGrupo.antilink = !configGrupo.antilink;
  fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
  const status = configGrupo.antilink ? 'ativado' : 'desativado';
  await sock.sendMessage(from, { text: `ğŸ”— Sistema AntiLink ${status}!` }, { quoted: msg });
}

else if (isGroup && msgLower === 'nuke') {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (senderSemDDD !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar.' }, { quoted: msg });
    return;
  }
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const membrosParaRemover = groupMetadata.participants
    .map(p => p.id)
    .filter(id => id !== botNumber);
  if (membrosParaRemover.length === 0) {
    await sock.sendMessage(from, { text: 'ğŸ‘¥ Nenhum membro para remover.' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { text: `ğŸ’£ Iniciando remoÃ§Ã£o de ${membrosParaRemover.length} membros...` }, { quoted: msg });
  for (const membro of membrosParaRemover) {
    try {
      await sock.groupParticipantsUpdate(from, [membro], 'remove');
      await new Promise(r => setTimeout(r, 3000));
    } catch (e) {
      console.error(`Erro ao remover ${membro}:`, e);
    }
  }
  await sock.sendMessage(from, { text: 'âœ…ğ—šğ—¿ğ˜‚ğ—½ğ—¼ ğ—¹ğ—¶ğ—ºğ—½ğ—¼ğŸ––' }, { quoted: msg });
}

if ((isGroup || !isGroup) && msgLower.startsWith('ideia')) {
  const fs = require('fs');
  const path = './dono/info.json';
  if (!fs.existsSync(path)) {
    await sock.sendMessage(from, { text: 'âŒ O nÃºmero do dono nÃ£o estÃ¡ configurado corretamente.' }, { quoted: msg });
    return;
  }
  const info = JSON.parse(fs.readFileSync(path));
  const numeroDono = info.numerodono + '@s.whatsapp.net';
  const ideiatxt = msg.message?.conversation
    || msg.message?.extendedTextMessage?.text
    || msg.message?.imageMessage?.caption
    || msg.message?.videoMessage?.caption
    || '';
  const partes = ideiatxt.trim().split(/\s+/);
  const ideiaTexto = partes.slice(1).join(' ').trim();
  if (!ideiaTexto) {
    await sock.sendMessage(from, { text: 'ğŸ’¡ Use: ideia sua sugestÃ£o aqui' }, { quoted: msg });
    return;
  }
  const remetente = sender.split('@')[0];
  const userTag = `@${remetente}`;
  const conteudo = `ğŸ’¡ *NOVA IDEIA ENVIADA:*\n\nğŸ‘¤ UsuÃ¡rio: ${userTag}\nğŸ”¢ NÃºmero: wa.me/${remetente}\n\nğŸ’¬ SugestÃ£o:\n"${ideiaTexto}"`;
  await sock.sendMessage(numeroDono, {
    text: conteudo,
    mentions: [sender]
  });
  await sock.sendMessage(from, {
    text: '_ğŸ˜ƒğŸ’• Sua ideia foi enviada com sucesso ğŸ¥³_',
    quoted: msg
  });
}

//  toimg
else if (/^([!.])?toimg$/i.test(msgLower)) {
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
  if (!quoted || !quoted.stickerMessage) {
    await sock.sendMessage(from, { text: 'âŒ Marque uma figurinha para converter.' }, { quoted: msg });
    return;
  }  
  try {
    const buffer = await downloadMediaMessage({ message: quoted }, 'buffer', {}, { reuploadRequest: sock });
    await sock.sendMessage(from, { image: buffer }, { quoted: msg });
  } catch (err) {
    await sock.sendMessage(from, { text: 'âŒ Erro ao converter figurinha.' }, { quoted: msg });
  }
}
//info gp
else if (isGroup && msgLower === 'infogp') {
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  await sock.sendMessage(from, {
    text: infoGp.infogp
  }, { quoted: msg });
}

else if (isGroup && /^([!.])?(infocookie)\b/i.test(msg.message?.conversation?.toLowerCase() || '')) {
  const info = `
*ğŸª COMO ATUALIZAR OS COOKIES DO YOUTUBE (RESTRITO)*

âœ… Siga esse passo a passo com atenÃ§Ã£o:

1ï¸âƒ£ Baixe o navegador *Yandex Browser*  
ğŸ“² https://play.google.com/store/apps/details?id=com.yandex.browser

2ï¸âƒ£ Instale a extensÃ£o *"Get cookies.txt"*  
ğŸ”— https://chrome.google.com/webstore/detail/get-cookiestxt/hdnnchgbgpkjpjegnlcgdjkkpdldpbpo  
Clique em *Adicionar ao Chrome*

3ï¸âƒ£ Acesse o site do *YouTube* no Yandex  
ğŸ” FaÃ§a login com uma conta maior de idade  
ğŸ“¼ Abra um vÃ­deo com restriÃ§Ã£o e dÃª *play*

4ï¸âƒ£ Clique nos 3 pontinhos > ExtensÃµes > *Get cookies.txt*  
Clique no botÃ£o *[Copiar]*

5ï¸âƒ£ Cole o conteÃºdo no arquivo:  
ğŸ“ */SanizinhaVip/dados/cookies/youtube.com_cookies.txt*

6ï¸âƒ£ Reinicie o bot

Pronto! Agora o bot vai conseguir baixar vÃ­deos com restriÃ§Ã£o de idade pelo comando *play* ou *playvd*. ğŸ’¿
`;

  await sock.sendMessage(from, { text: info }, { quoted: msg });
}

//__-_-_-_-_-___-_-__-_-_-_-_-_-_-_//
else if (isGroup && msg.message?.extendedTextMessage?.contextInfo && msgLower === 'totag') {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const quoted = msg.message.extendedTextMessage.contextInfo.quotedMessage;
  if (!quoted) {
    await sock.sendMessage(from, { text: 'âŒ Responda a uma mensagem para marcar todos.' }, { quoted: msg });
    return;
  }
  const tipo = Object.keys(quoted)[0];
  const participantes = grupoInfo.participants.map(p => p.id);
  try {
    if (tipo === 'conversation') {
      const texto = quoted.conversation || '';
      await sock.sendMessage(from, {
        text: texto,
        mentions: participantes
      }, { quoted: msg });
      return;
    }
    if (tipo === 'extendedTextMessage') {
      const texto = quoted.extendedTextMessage?.text || quoted.extendedTextMessage?.contextInfo?.quotedMessage?.conversation || '';
      await sock.sendMessage(from, {
        text: texto,
        mentions: participantes
      }, { quoted: msg });
      return;
    }
    const stream = await downloadContentFromMessage(quoted[tipo], tipo.replace('Message', ''));
    let buffer = Buffer.from([]);
    for await (const chunk of stream) {
      buffer = Buffer.concat([buffer, chunk]);
    }
    if (tipo === 'stickerMessage') {
      await sock.sendMessage(from, {
        sticker: buffer,
        mentions: participantes
      }, { quoted: msg });
    } else if (tipo === 'imageMessage') {
      await sock.sendMessage(from, {
        image: buffer,
        caption: quoted[tipo].caption || '',
        mentions: participantes
      }, { quoted: msg });
    } else if (tipo === 'videoMessage') {
      await sock.sendMessage(from, {
        video: buffer,
        caption: quoted[tipo].caption || '',
        mentions: participantes
      }, { quoted: msg });
    } else if (tipo === 'audioMessage') {
      await sock.sendMessage(from, {
        audio: buffer,
        mimetype: quoted[tipo].mimetype || 'audio/ogg; codecs=opus',
        ptt: quoted[tipo].ptt || false,
        mentions: participantes
      }, { quoted: msg });
    } else {
      await sock.sendMessage(from, {
        text: 'âŒ Tipo de mensagem nÃ£o suportado para marcaÃ§Ã£o.',
        mentions: participantes
      }, { quoted: msg });
    }
  } catch (e) {
    console.error('Erro no comando .totag:', e);
    await sock.sendMessage(from, { text: 'âŒ NÃ£o foi possÃ­vel reenviar a mensagem. Tipo de mÃ­dia nÃ£o suportado ou corrompido.' }, { quoted: msg });
  }
}
//=================================//
else if (isGroup && (msgLower === 'marcar' || msgLower === 'cita')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const participantes = groupMetadata.participants.map(p => p.id);
  const texto = participantes.map((p, i) => `ğŸ”¹ ${i + 1}. @${p.split('@')[0]}`).join('\n');
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(from, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/g3o2dt.gif';
  }
  const thumbnailBuffer = await axios.get(ppUrl, { responseType: 'arraybuffer' }).then(res => res.data);
  await sock.sendMessage(from, {
    text: `ğŸ“¢ğŸ¥³ğğğ‘ğ€ ğˆğğ“ğ„ğ‘ğ€ğ†ğˆğ‘âœ¨ğŸ¥³\n\n${texto}`,
    mentions: participantes,
    contextInfo: {
      mentionedJid: participantes,
      externalAdReply: {
        title: 'ğ’ğ€ğˆ ğƒğ€ ğŒğğˆğ“ğ€ ğğ‹ğ€ğ“ğˆğğ€ğŸ˜‚â•',
        body: 'ğŒğ„ğŒğğ‘ğğ’ ğˆğğ€ğ“ğˆğ•ğğ’ ğ•ğ€ğˆ ğˆğ‘ ğƒğ„ ğ…ğŸª¦',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: true,
        sourceUrl: 'https://ğ˜¯ğ˜¦ğ˜¹ğ˜°ğ˜´ğ˜°ğ˜§ğ˜¤'
      }
    }
  }, { quoted: msg });
}
///==================================//
else if (isGroup && msgLower === 'blockgp') {
  const configGrupo = carregarConfigGrupo(from);
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (!isGroupAdmin && senderSemDDD !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores ou o dono podem usar este comando.' }, { quoted: msg });
    return;
  }
  configGrupo.blockgp = !configGrupo.blockgp;
  salvarConfigGrupo(from, configGrupo);
  const estado = configGrupo.blockgp ? 'ativado' : 'desativado';
  await sock.sendMessage(from, { text: `Modo somente admin ${estado}.` }, { quoted: msg });
}

if (
  isGroup &&
  (msgLower === 'gpa' || msgLower === 'gpf' || msgLower.startsWith('gpa ') || msgLower.startsWith('gpf '))
) {
  const tipo = msgLower.startsWith('gpa') ? 'gpa' : 'gpf';
  const partes = msgLower.trim().split(/\s+/);
  const argumento = partes.slice(1).join(' ').trim();

  if (!argumento) {
    await executarAgendamento(from, tipo);
    await sock.sendMessage(from, {
      text: tipo === 'gpa' ? 'âœ… *GRUPO ABERTO*' : 'âœ… *GRUPO FECHADO*'
    }, { quoted: msg });
    return;
  }

  let h, m;

  // Aceita formato HH:MM
  if (/^\d{1,2}:\d{2}$/.test(argumento)) {
    [h, m] = argumento.split(':').map(Number);

  // Aceita formato tipo "12h 30m" ou "6h 5m"
  } else if (/^\d{1,2}h\s*\d{1,2}m$/.test(argumento.replace(/\s+/g, ''))) {
    const match = argumento.match(/(\d{1,2})h\s*(\d{1,2})m/);
    if (match) {
      h = Number(match[1]);
      m = Number(match[2]);
    }
  }

  if (h === undefined || m === undefined || h > 23 || m > 59) {
    await sock.sendMessage(from, {
      text: 'âŒ Use o formato correto: `HH:MM` ou `HHh MMm`\nExemplo: `gpa 22:30` ou `gpf 6h 0m`'
    }, { quoted: msg });
    return;
  }

  if (!agendamentos[from]) agendamentos[from] = {};
  agendamentos[from][tipo] = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;

  await sock.sendMessage(from, {
    text: `ğŸ• ${tipo === 'gpa' ? '*ABRIR*' : '*FECHAR*'} grupo agendado para *${agendamentos[from][tipo]}*.`
  }, { quoted: msg });
}
// Comando .antifake
else if (isGroup && msgLower === 'antifake') {
  const configGrupo = carregarConfigGrupo(from);
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderSemDDD = sender.split('@')[0].replace(/\D/g, '');
  if (!isGroupAdmin && senderSemDDD !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  configGrupo.antifake = !configGrupo.antifake;
  salvarConfigGrupo(from, configGrupo);
  const estado = configGrupo.antifake ? 'ativado' : 'desativado';
  await sock.sendMessage(from, {
    text: `ğ—”ğ—»ğ˜ğ—¶ğ—³ğ—®ğ—¸ğ—² ${estado}.`,
  }, { quoted: msg });
}
  
  else if (isGroup && msgLower.startsWith('bemvindo')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  configGrupo.bemvindo = !configGrupo.bemvindo;
  salvarConfigGrupo(from, configGrupo);
  await sock.sendMessage(
    from,
    { text: `ğ—•ğ—¼ğ—®ğ˜€-ğ˜ƒğ—¶ğ—»ğ—±ğ—®ğ˜€ ${configGrupo.bemvindo ? 'ativado' : 'desativado'} \nCaso queira personalizar digite legendabv!` },
    { quoted: msg }
  );
}
  else if (isGroup && msgLower.startsWith('legendabv')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas administradores podem usar este comando.'
    }, { quoted: msg });
    return;
  }
  const configGrupo = carregarConfigGrupo(from);
  const novoTexto = text.slice('legendabv'.length).trim();
  if (novoTexto.length < 5) {
    await sock.sendMessage(from, {
      text: 'Use legendabv oi #ğ—ºğ—²ğ—ºğ—¯ğ—¿ğ—¼# seja bem vindo(a) ao #ğ—´ğ—¿ğ˜‚ğ—½ğ—¼#\n \n#ğ—ºğ—²ğ—ºğ—¯ğ—¿ğ—¼# serve para marcar o usuario\n \n#ğ—´ğ—¿ğ˜‚ğ—½ğ—¼# serve para exibir o nome do grupo\n \nâŒ Por favor, envie uma mensagem de boas-vindas com pelo menos 5 caracteres.\n _Isso tudo Ã© opcional, personalize do geito q quiser, boa sorteğŸ’š_'
    }, { quoted: msg });
    return;
  }
  configGrupo.legendabv = novoTexto;
  salvarConfigGrupo(from, configGrupo);
  await sock.sendMessage(from, {
    text: 'âœ…ğ— ğ—²ğ—»ğ˜€ğ—®ğ—´ğ—²ğ—º ğ—±ğ—² ğ—¯ğ—¼ğ—®ğ˜€-ğ˜ƒğ—¶ğ—»ğ—±ğ—®ğ˜€ ğ—®ğ˜ğ˜‚ğ—®ğ—¹ğ—¶ğ˜‡ğ—®ğ—±ğ—®!'
  }, { quoted: msg });
}
}
 // sock.ev
// Evento para boas-vindas
async function onGroupParticipantsUpdate(update, sock) {
  try {
    const groupId = update.id;
    const configPath = `./dados/grupos/${groupId}.json`;
    let configGrupo = {};
    if (fs.existsSync(configPath)) {
      configGrupo = JSON.parse(fs.readFileSync(configPath));
    }

    let groupMetadata = null;
    if (configGrupo.antifake || configGrupo.bemvindo) {
      try {
        groupMetadata = await sock.groupMetadata(groupId);
      } catch (e) {
        console.error('Erro ao obter metadata do grupo:', e);
      }
    }

    for (const participant of update.participants) {
      // ğŸ”’ AntiFake
      if (update.action === 'add' && configGrupo.antifake) {
        const isAdmin = (userId) =>
          groupMetadata.participants.find(p => p.id === userId)?.admin;
        const isAdm = isAdmin(participant);
        if (!isAdm && !participant.startsWith('55')) {
          await sock.groupParticipantsUpdate(groupId, [participant], 'remove');
          continue; // pula para o prÃ³ximo participante
        }
      }

      // ğŸ‘‹ Mensagem de boas-vindas
if (update.action === 'add' && configGrupo.bemvindo) {
  const texto = configGrupo.legendabv
    .replace(/#membro#/g, `@${participant.split('@')[0]}`)
    .replace(/#grupo#/g, groupMetadata?.subject || 'o grupo');

  let profilePicBuffer = null;
  try {
    const groupPicUrl = await sock.profilePictureUrl(groupId, 'image');
    if (groupPicUrl) {
      const picData = await axios.get(groupPicUrl, { responseType: 'arraybuffer' });
      profilePicBuffer = picData.data;
    }
  } catch (e) {
    console.warn('Erro ao obter foto do grupo:', e);
  }

  await sock.sendMessage(groupId, {
    text: texto,
    mentions: [participant],
    contextInfo: {
      mentionedJid: [participant],
      externalAdReply: {
        title: `ğŸŒ¸ Bem-vindo(a) ao grupo ${groupMetadata?.subject || 'desconhecido'}!`,
        body: 'âœ¨ SanizinhaBot âœ¨',
        thumbnail: profilePicBuffer,
        mediaType: 1,
        showAdAttribution: true,
        sourceUrl: 'https://wa.me/' + participant.split('@')[0]
      }
    }
  });
}

      // Lista negra
      if (update.action === 'add' && configGrupo.listanegra?.includes(participant)) {
        await sock.groupParticipantsUpdate(groupId, [participant], 'remove');
        await sock.sendMessage(groupId, { text: `UsuÃ¡rio removido da lista negra: @${participant.split('@')[0]}` });
        continue;
      }
    }
  } catch (e) {
    console.error('Erro em onGroupParticipantsUpdate:', e);
  }
}

// antipromote - pode ser outra funÃ§Ã£o com outro nome para nÃ£o conflitar
async function onGroupParticipantsPromote(update, sock) {
  const { id, participants, action, author } = update;
  if (action !== 'promote') return;

  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const grupoPath = path.resolve(__dirname, `./dados/grupos/${id}.json`);
  if (!fs.existsSync(grupoPath)) return;

  const configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  if (!configGrupo.antipromote) return;

  const donoPath = path.resolve(__dirname, './dono/info.json');
  if (!fs.existsSync(donoPath)) return;

  const dono = JSON.parse(fs.readFileSync(donoPath))?.dono?.replace(/\D/g, '') + '@s.whatsapp.net';

  try {
    for (const promovido of participants) {
      const isPromotorDono = author === dono;
      const isPromotorBot = author === botNumber;
      if (!isPromotorDono && !isPromotorBot) {
        await sock.groupParticipantsUpdate(id, [author, promovido], 'demote');
        await sock.sendMessage(id, {
          text: `â›” PromoÃ§Ã£o manual detectada!\n@${author.split('@')[0]} e @${promovido.split('@')[0]} foram rebaixados.`,
          mentions: [author, promovido]
        });
      }
    }
  } catch (err) {
    console.log('Erro anti-promote manual:', err);
  }
}

module.exports = {
  upsert,
  onGroupParticipantsUpdate,
  onGroupParticipantsPromote, // exporte a funÃ§Ã£o separada
  setSock,
};